"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/dompurify";
exports.ids = ["vendor-chunks/dompurify"];
exports.modules = {

/***/ "(ssr)/./node_modules/dompurify/dist/purify.es.mjs":
/*!***************************************************!*\
  !*** ./node_modules/dompurify/dist/purify.es.mjs ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ purify)\n/* harmony export */ });\n/*! @license DOMPurify 3.2.4 | (c) Cure53 and other contributors | Released under the Apache license 2.0 and Mozilla Public License 2.0 | github.com/cure53/DOMPurify/blob/3.2.4/LICENSE */ const { entries, setPrototypeOf, isFrozen, getPrototypeOf, getOwnPropertyDescriptor } = Object;\nlet { freeze, seal, create } = Object; // eslint-disable-line import/no-mutable-exports\nlet { apply, construct } = typeof Reflect !== \"undefined\" && Reflect;\nif (!freeze) {\n    freeze = function freeze(x) {\n        return x;\n    };\n}\nif (!seal) {\n    seal = function seal(x) {\n        return x;\n    };\n}\nif (!apply) {\n    apply = function apply(fun, thisValue, args) {\n        return fun.apply(thisValue, args);\n    };\n}\nif (!construct) {\n    construct = function construct(Func, args) {\n        return new Func(...args);\n    };\n}\nconst arrayForEach = unapply(Array.prototype.forEach);\nconst arrayLastIndexOf = unapply(Array.prototype.lastIndexOf);\nconst arrayPop = unapply(Array.prototype.pop);\nconst arrayPush = unapply(Array.prototype.push);\nconst arraySplice = unapply(Array.prototype.splice);\nconst stringToLowerCase = unapply(String.prototype.toLowerCase);\nconst stringToString = unapply(String.prototype.toString);\nconst stringMatch = unapply(String.prototype.match);\nconst stringReplace = unapply(String.prototype.replace);\nconst stringIndexOf = unapply(String.prototype.indexOf);\nconst stringTrim = unapply(String.prototype.trim);\nconst objectHasOwnProperty = unapply(Object.prototype.hasOwnProperty);\nconst regExpTest = unapply(RegExp.prototype.test);\nconst typeErrorCreate = unconstruct(TypeError);\n/**\n * Creates a new function that calls the given function with a specified thisArg and arguments.\n *\n * @param func - The function to be wrapped and called.\n * @returns A new function that calls the given function with a specified thisArg and arguments.\n */ function unapply(func) {\n    return function(thisArg) {\n        for(var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){\n            args[_key - 1] = arguments[_key];\n        }\n        return apply(func, thisArg, args);\n    };\n}\n/**\n * Creates a new function that constructs an instance of the given constructor function with the provided arguments.\n *\n * @param func - The constructor function to be wrapped and called.\n * @returns A new function that constructs an instance of the given constructor function with the provided arguments.\n */ function unconstruct(func) {\n    return function() {\n        for(var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++){\n            args[_key2] = arguments[_key2];\n        }\n        return construct(func, args);\n    };\n}\n/**\n * Add properties to a lookup table\n *\n * @param set - The set to which elements will be added.\n * @param array - The array containing elements to be added to the set.\n * @param transformCaseFunc - An optional function to transform the case of each element before adding to the set.\n * @returns The modified set with added elements.\n */ function addToSet(set, array) {\n    let transformCaseFunc = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : stringToLowerCase;\n    if (setPrototypeOf) {\n        // Make 'in' and truthy checks like Boolean(set.constructor)\n        // independent of any properties defined on Object.prototype.\n        // Prevent prototype setters from intercepting set as a this value.\n        setPrototypeOf(set, null);\n    }\n    let l = array.length;\n    while(l--){\n        let element = array[l];\n        if (typeof element === \"string\") {\n            const lcElement = transformCaseFunc(element);\n            if (lcElement !== element) {\n                // Config presets (e.g. tags.js, attrs.js) are immutable.\n                if (!isFrozen(array)) {\n                    array[l] = lcElement;\n                }\n                element = lcElement;\n            }\n        }\n        set[element] = true;\n    }\n    return set;\n}\n/**\n * Clean up an array to harden against CSPP\n *\n * @param array - The array to be cleaned.\n * @returns The cleaned version of the array\n */ function cleanArray(array) {\n    for(let index = 0; index < array.length; index++){\n        const isPropertyExist = objectHasOwnProperty(array, index);\n        if (!isPropertyExist) {\n            array[index] = null;\n        }\n    }\n    return array;\n}\n/**\n * Shallow clone an object\n *\n * @param object - The object to be cloned.\n * @returns A new object that copies the original.\n */ function clone(object) {\n    const newObject = create(null);\n    for (const [property, value] of entries(object)){\n        const isPropertyExist = objectHasOwnProperty(object, property);\n        if (isPropertyExist) {\n            if (Array.isArray(value)) {\n                newObject[property] = cleanArray(value);\n            } else if (value && typeof value === \"object\" && value.constructor === Object) {\n                newObject[property] = clone(value);\n            } else {\n                newObject[property] = value;\n            }\n        }\n    }\n    return newObject;\n}\n/**\n * This method automatically checks if the prop is function or getter and behaves accordingly.\n *\n * @param object - The object to look up the getter function in its prototype chain.\n * @param prop - The property name for which to find the getter function.\n * @returns The getter function found in the prototype chain or a fallback function.\n */ function lookupGetter(object, prop) {\n    while(object !== null){\n        const desc = getOwnPropertyDescriptor(object, prop);\n        if (desc) {\n            if (desc.get) {\n                return unapply(desc.get);\n            }\n            if (typeof desc.value === \"function\") {\n                return unapply(desc.value);\n            }\n        }\n        object = getPrototypeOf(object);\n    }\n    function fallbackValue() {\n        return null;\n    }\n    return fallbackValue;\n}\nconst html$1 = freeze([\n    \"a\",\n    \"abbr\",\n    \"acronym\",\n    \"address\",\n    \"area\",\n    \"article\",\n    \"aside\",\n    \"audio\",\n    \"b\",\n    \"bdi\",\n    \"bdo\",\n    \"big\",\n    \"blink\",\n    \"blockquote\",\n    \"body\",\n    \"br\",\n    \"button\",\n    \"canvas\",\n    \"caption\",\n    \"center\",\n    \"cite\",\n    \"code\",\n    \"col\",\n    \"colgroup\",\n    \"content\",\n    \"data\",\n    \"datalist\",\n    \"dd\",\n    \"decorator\",\n    \"del\",\n    \"details\",\n    \"dfn\",\n    \"dialog\",\n    \"dir\",\n    \"div\",\n    \"dl\",\n    \"dt\",\n    \"element\",\n    \"em\",\n    \"fieldset\",\n    \"figcaption\",\n    \"figure\",\n    \"font\",\n    \"footer\",\n    \"form\",\n    \"h1\",\n    \"h2\",\n    \"h3\",\n    \"h4\",\n    \"h5\",\n    \"h6\",\n    \"head\",\n    \"header\",\n    \"hgroup\",\n    \"hr\",\n    \"html\",\n    \"i\",\n    \"img\",\n    \"input\",\n    \"ins\",\n    \"kbd\",\n    \"label\",\n    \"legend\",\n    \"li\",\n    \"main\",\n    \"map\",\n    \"mark\",\n    \"marquee\",\n    \"menu\",\n    \"menuitem\",\n    \"meter\",\n    \"nav\",\n    \"nobr\",\n    \"ol\",\n    \"optgroup\",\n    \"option\",\n    \"output\",\n    \"p\",\n    \"picture\",\n    \"pre\",\n    \"progress\",\n    \"q\",\n    \"rp\",\n    \"rt\",\n    \"ruby\",\n    \"s\",\n    \"samp\",\n    \"section\",\n    \"select\",\n    \"shadow\",\n    \"small\",\n    \"source\",\n    \"spacer\",\n    \"span\",\n    \"strike\",\n    \"strong\",\n    \"style\",\n    \"sub\",\n    \"summary\",\n    \"sup\",\n    \"table\",\n    \"tbody\",\n    \"td\",\n    \"template\",\n    \"textarea\",\n    \"tfoot\",\n    \"th\",\n    \"thead\",\n    \"time\",\n    \"tr\",\n    \"track\",\n    \"tt\",\n    \"u\",\n    \"ul\",\n    \"var\",\n    \"video\",\n    \"wbr\"\n]);\nconst svg$1 = freeze([\n    \"svg\",\n    \"a\",\n    \"altglyph\",\n    \"altglyphdef\",\n    \"altglyphitem\",\n    \"animatecolor\",\n    \"animatemotion\",\n    \"animatetransform\",\n    \"circle\",\n    \"clippath\",\n    \"defs\",\n    \"desc\",\n    \"ellipse\",\n    \"filter\",\n    \"font\",\n    \"g\",\n    \"glyph\",\n    \"glyphref\",\n    \"hkern\",\n    \"image\",\n    \"line\",\n    \"lineargradient\",\n    \"marker\",\n    \"mask\",\n    \"metadata\",\n    \"mpath\",\n    \"path\",\n    \"pattern\",\n    \"polygon\",\n    \"polyline\",\n    \"radialgradient\",\n    \"rect\",\n    \"stop\",\n    \"style\",\n    \"switch\",\n    \"symbol\",\n    \"text\",\n    \"textpath\",\n    \"title\",\n    \"tref\",\n    \"tspan\",\n    \"view\",\n    \"vkern\"\n]);\nconst svgFilters = freeze([\n    \"feBlend\",\n    \"feColorMatrix\",\n    \"feComponentTransfer\",\n    \"feComposite\",\n    \"feConvolveMatrix\",\n    \"feDiffuseLighting\",\n    \"feDisplacementMap\",\n    \"feDistantLight\",\n    \"feDropShadow\",\n    \"feFlood\",\n    \"feFuncA\",\n    \"feFuncB\",\n    \"feFuncG\",\n    \"feFuncR\",\n    \"feGaussianBlur\",\n    \"feImage\",\n    \"feMerge\",\n    \"feMergeNode\",\n    \"feMorphology\",\n    \"feOffset\",\n    \"fePointLight\",\n    \"feSpecularLighting\",\n    \"feSpotLight\",\n    \"feTile\",\n    \"feTurbulence\"\n]);\n// List of SVG elements that are disallowed by default.\n// We still need to know them so that we can do namespace\n// checks properly in case one wants to add them to\n// allow-list.\nconst svgDisallowed = freeze([\n    \"animate\",\n    \"color-profile\",\n    \"cursor\",\n    \"discard\",\n    \"font-face\",\n    \"font-face-format\",\n    \"font-face-name\",\n    \"font-face-src\",\n    \"font-face-uri\",\n    \"foreignobject\",\n    \"hatch\",\n    \"hatchpath\",\n    \"mesh\",\n    \"meshgradient\",\n    \"meshpatch\",\n    \"meshrow\",\n    \"missing-glyph\",\n    \"script\",\n    \"set\",\n    \"solidcolor\",\n    \"unknown\",\n    \"use\"\n]);\nconst mathMl$1 = freeze([\n    \"math\",\n    \"menclose\",\n    \"merror\",\n    \"mfenced\",\n    \"mfrac\",\n    \"mglyph\",\n    \"mi\",\n    \"mlabeledtr\",\n    \"mmultiscripts\",\n    \"mn\",\n    \"mo\",\n    \"mover\",\n    \"mpadded\",\n    \"mphantom\",\n    \"mroot\",\n    \"mrow\",\n    \"ms\",\n    \"mspace\",\n    \"msqrt\",\n    \"mstyle\",\n    \"msub\",\n    \"msup\",\n    \"msubsup\",\n    \"mtable\",\n    \"mtd\",\n    \"mtext\",\n    \"mtr\",\n    \"munder\",\n    \"munderover\",\n    \"mprescripts\"\n]);\n// Similarly to SVG, we want to know all MathML elements,\n// even those that we disallow by default.\nconst mathMlDisallowed = freeze([\n    \"maction\",\n    \"maligngroup\",\n    \"malignmark\",\n    \"mlongdiv\",\n    \"mscarries\",\n    \"mscarry\",\n    \"msgroup\",\n    \"mstack\",\n    \"msline\",\n    \"msrow\",\n    \"semantics\",\n    \"annotation\",\n    \"annotation-xml\",\n    \"mprescripts\",\n    \"none\"\n]);\nconst text = freeze([\n    \"#text\"\n]);\nconst html = freeze([\n    \"accept\",\n    \"action\",\n    \"align\",\n    \"alt\",\n    \"autocapitalize\",\n    \"autocomplete\",\n    \"autopictureinpicture\",\n    \"autoplay\",\n    \"background\",\n    \"bgcolor\",\n    \"border\",\n    \"capture\",\n    \"cellpadding\",\n    \"cellspacing\",\n    \"checked\",\n    \"cite\",\n    \"class\",\n    \"clear\",\n    \"color\",\n    \"cols\",\n    \"colspan\",\n    \"controls\",\n    \"controlslist\",\n    \"coords\",\n    \"crossorigin\",\n    \"datetime\",\n    \"decoding\",\n    \"default\",\n    \"dir\",\n    \"disabled\",\n    \"disablepictureinpicture\",\n    \"disableremoteplayback\",\n    \"download\",\n    \"draggable\",\n    \"enctype\",\n    \"enterkeyhint\",\n    \"face\",\n    \"for\",\n    \"headers\",\n    \"height\",\n    \"hidden\",\n    \"high\",\n    \"href\",\n    \"hreflang\",\n    \"id\",\n    \"inputmode\",\n    \"integrity\",\n    \"ismap\",\n    \"kind\",\n    \"label\",\n    \"lang\",\n    \"list\",\n    \"loading\",\n    \"loop\",\n    \"low\",\n    \"max\",\n    \"maxlength\",\n    \"media\",\n    \"method\",\n    \"min\",\n    \"minlength\",\n    \"multiple\",\n    \"muted\",\n    \"name\",\n    \"nonce\",\n    \"noshade\",\n    \"novalidate\",\n    \"nowrap\",\n    \"open\",\n    \"optimum\",\n    \"pattern\",\n    \"placeholder\",\n    \"playsinline\",\n    \"popover\",\n    \"popovertarget\",\n    \"popovertargetaction\",\n    \"poster\",\n    \"preload\",\n    \"pubdate\",\n    \"radiogroup\",\n    \"readonly\",\n    \"rel\",\n    \"required\",\n    \"rev\",\n    \"reversed\",\n    \"role\",\n    \"rows\",\n    \"rowspan\",\n    \"spellcheck\",\n    \"scope\",\n    \"selected\",\n    \"shape\",\n    \"size\",\n    \"sizes\",\n    \"span\",\n    \"srclang\",\n    \"start\",\n    \"src\",\n    \"srcset\",\n    \"step\",\n    \"style\",\n    \"summary\",\n    \"tabindex\",\n    \"title\",\n    \"translate\",\n    \"type\",\n    \"usemap\",\n    \"valign\",\n    \"value\",\n    \"width\",\n    \"wrap\",\n    \"xmlns\",\n    \"slot\"\n]);\nconst svg = freeze([\n    \"accent-height\",\n    \"accumulate\",\n    \"additive\",\n    \"alignment-baseline\",\n    \"amplitude\",\n    \"ascent\",\n    \"attributename\",\n    \"attributetype\",\n    \"azimuth\",\n    \"basefrequency\",\n    \"baseline-shift\",\n    \"begin\",\n    \"bias\",\n    \"by\",\n    \"class\",\n    \"clip\",\n    \"clippathunits\",\n    \"clip-path\",\n    \"clip-rule\",\n    \"color\",\n    \"color-interpolation\",\n    \"color-interpolation-filters\",\n    \"color-profile\",\n    \"color-rendering\",\n    \"cx\",\n    \"cy\",\n    \"d\",\n    \"dx\",\n    \"dy\",\n    \"diffuseconstant\",\n    \"direction\",\n    \"display\",\n    \"divisor\",\n    \"dur\",\n    \"edgemode\",\n    \"elevation\",\n    \"end\",\n    \"exponent\",\n    \"fill\",\n    \"fill-opacity\",\n    \"fill-rule\",\n    \"filter\",\n    \"filterunits\",\n    \"flood-color\",\n    \"flood-opacity\",\n    \"font-family\",\n    \"font-size\",\n    \"font-size-adjust\",\n    \"font-stretch\",\n    \"font-style\",\n    \"font-variant\",\n    \"font-weight\",\n    \"fx\",\n    \"fy\",\n    \"g1\",\n    \"g2\",\n    \"glyph-name\",\n    \"glyphref\",\n    \"gradientunits\",\n    \"gradienttransform\",\n    \"height\",\n    \"href\",\n    \"id\",\n    \"image-rendering\",\n    \"in\",\n    \"in2\",\n    \"intercept\",\n    \"k\",\n    \"k1\",\n    \"k2\",\n    \"k3\",\n    \"k4\",\n    \"kerning\",\n    \"keypoints\",\n    \"keysplines\",\n    \"keytimes\",\n    \"lang\",\n    \"lengthadjust\",\n    \"letter-spacing\",\n    \"kernelmatrix\",\n    \"kernelunitlength\",\n    \"lighting-color\",\n    \"local\",\n    \"marker-end\",\n    \"marker-mid\",\n    \"marker-start\",\n    \"markerheight\",\n    \"markerunits\",\n    \"markerwidth\",\n    \"maskcontentunits\",\n    \"maskunits\",\n    \"max\",\n    \"mask\",\n    \"media\",\n    \"method\",\n    \"mode\",\n    \"min\",\n    \"name\",\n    \"numoctaves\",\n    \"offset\",\n    \"operator\",\n    \"opacity\",\n    \"order\",\n    \"orient\",\n    \"orientation\",\n    \"origin\",\n    \"overflow\",\n    \"paint-order\",\n    \"path\",\n    \"pathlength\",\n    \"patterncontentunits\",\n    \"patterntransform\",\n    \"patternunits\",\n    \"points\",\n    \"preservealpha\",\n    \"preserveaspectratio\",\n    \"primitiveunits\",\n    \"r\",\n    \"rx\",\n    \"ry\",\n    \"radius\",\n    \"refx\",\n    \"refy\",\n    \"repeatcount\",\n    \"repeatdur\",\n    \"restart\",\n    \"result\",\n    \"rotate\",\n    \"scale\",\n    \"seed\",\n    \"shape-rendering\",\n    \"slope\",\n    \"specularconstant\",\n    \"specularexponent\",\n    \"spreadmethod\",\n    \"startoffset\",\n    \"stddeviation\",\n    \"stitchtiles\",\n    \"stop-color\",\n    \"stop-opacity\",\n    \"stroke-dasharray\",\n    \"stroke-dashoffset\",\n    \"stroke-linecap\",\n    \"stroke-linejoin\",\n    \"stroke-miterlimit\",\n    \"stroke-opacity\",\n    \"stroke\",\n    \"stroke-width\",\n    \"style\",\n    \"surfacescale\",\n    \"systemlanguage\",\n    \"tabindex\",\n    \"tablevalues\",\n    \"targetx\",\n    \"targety\",\n    \"transform\",\n    \"transform-origin\",\n    \"text-anchor\",\n    \"text-decoration\",\n    \"text-rendering\",\n    \"textlength\",\n    \"type\",\n    \"u1\",\n    \"u2\",\n    \"unicode\",\n    \"values\",\n    \"viewbox\",\n    \"visibility\",\n    \"version\",\n    \"vert-adv-y\",\n    \"vert-origin-x\",\n    \"vert-origin-y\",\n    \"width\",\n    \"word-spacing\",\n    \"wrap\",\n    \"writing-mode\",\n    \"xchannelselector\",\n    \"ychannelselector\",\n    \"x\",\n    \"x1\",\n    \"x2\",\n    \"xmlns\",\n    \"y\",\n    \"y1\",\n    \"y2\",\n    \"z\",\n    \"zoomandpan\"\n]);\nconst mathMl = freeze([\n    \"accent\",\n    \"accentunder\",\n    \"align\",\n    \"bevelled\",\n    \"close\",\n    \"columnsalign\",\n    \"columnlines\",\n    \"columnspan\",\n    \"denomalign\",\n    \"depth\",\n    \"dir\",\n    \"display\",\n    \"displaystyle\",\n    \"encoding\",\n    \"fence\",\n    \"frame\",\n    \"height\",\n    \"href\",\n    \"id\",\n    \"largeop\",\n    \"length\",\n    \"linethickness\",\n    \"lspace\",\n    \"lquote\",\n    \"mathbackground\",\n    \"mathcolor\",\n    \"mathsize\",\n    \"mathvariant\",\n    \"maxsize\",\n    \"minsize\",\n    \"movablelimits\",\n    \"notation\",\n    \"numalign\",\n    \"open\",\n    \"rowalign\",\n    \"rowlines\",\n    \"rowspacing\",\n    \"rowspan\",\n    \"rspace\",\n    \"rquote\",\n    \"scriptlevel\",\n    \"scriptminsize\",\n    \"scriptsizemultiplier\",\n    \"selection\",\n    \"separator\",\n    \"separators\",\n    \"stretchy\",\n    \"subscriptshift\",\n    \"supscriptshift\",\n    \"symmetric\",\n    \"voffset\",\n    \"width\",\n    \"xmlns\"\n]);\nconst xml = freeze([\n    \"xlink:href\",\n    \"xml:id\",\n    \"xlink:title\",\n    \"xml:space\",\n    \"xmlns:xlink\"\n]);\n// eslint-disable-next-line unicorn/better-regex\nconst MUSTACHE_EXPR = seal(/\\{\\{[\\w\\W]*|[\\w\\W]*\\}\\}/gm); // Specify template detection regex for SAFE_FOR_TEMPLATES mode\nconst ERB_EXPR = seal(/<%[\\w\\W]*|[\\w\\W]*%>/gm);\nconst TMPLIT_EXPR = seal(/\\$\\{[\\w\\W]*/gm); // eslint-disable-line unicorn/better-regex\nconst DATA_ATTR = seal(/^data-[\\-\\w.\\u00B7-\\uFFFF]+$/); // eslint-disable-line no-useless-escape\nconst ARIA_ATTR = seal(/^aria-[\\-\\w]+$/); // eslint-disable-line no-useless-escape\nconst IS_ALLOWED_URI = seal(/^(?:(?:(?:f|ht)tps?|mailto|tel|callto|sms|cid|xmpp):|[^a-z]|[a-z+.\\-]+(?:[^a-z+.\\-:]|$))/i // eslint-disable-line no-useless-escape\n);\nconst IS_SCRIPT_OR_DATA = seal(/^(?:\\w+script|data):/i);\nconst ATTR_WHITESPACE = seal(/[\\u0000-\\u0020\\u00A0\\u1680\\u180E\\u2000-\\u2029\\u205F\\u3000]/g // eslint-disable-line no-control-regex\n);\nconst DOCTYPE_NAME = seal(/^html$/i);\nconst CUSTOM_ELEMENT = seal(/^[a-z][.\\w]*(-[.\\w]+)+$/i);\nvar EXPRESSIONS = /*#__PURE__*/ Object.freeze({\n    __proto__: null,\n    ARIA_ATTR: ARIA_ATTR,\n    ATTR_WHITESPACE: ATTR_WHITESPACE,\n    CUSTOM_ELEMENT: CUSTOM_ELEMENT,\n    DATA_ATTR: DATA_ATTR,\n    DOCTYPE_NAME: DOCTYPE_NAME,\n    ERB_EXPR: ERB_EXPR,\n    IS_ALLOWED_URI: IS_ALLOWED_URI,\n    IS_SCRIPT_OR_DATA: IS_SCRIPT_OR_DATA,\n    MUSTACHE_EXPR: MUSTACHE_EXPR,\n    TMPLIT_EXPR: TMPLIT_EXPR\n});\n/* eslint-disable @typescript-eslint/indent */ // https://developer.mozilla.org/en-US/docs/Web/API/Node/nodeType\nconst NODE_TYPE = {\n    element: 1,\n    attribute: 2,\n    text: 3,\n    cdataSection: 4,\n    entityReference: 5,\n    // Deprecated\n    entityNode: 6,\n    // Deprecated\n    progressingInstruction: 7,\n    comment: 8,\n    document: 9,\n    documentType: 10,\n    documentFragment: 11,\n    notation: 12 // Deprecated\n};\nconst getGlobal = function getGlobal() {\n    return  true ? null : 0;\n};\n/**\n * Creates a no-op policy for internal use only.\n * Don't export this function outside this module!\n * @param trustedTypes The policy factory.\n * @param purifyHostElement The Script element used to load DOMPurify (to determine policy name suffix).\n * @return The policy created (or null, if Trusted Types\n * are not supported or creating the policy failed).\n */ const _createTrustedTypesPolicy = function _createTrustedTypesPolicy(trustedTypes, purifyHostElement) {\n    if (typeof trustedTypes !== \"object\" || typeof trustedTypes.createPolicy !== \"function\") {\n        return null;\n    }\n    // Allow the callers to control the unique policy name\n    // by adding a data-tt-policy-suffix to the script element with the DOMPurify.\n    // Policy creation with duplicate names throws in Trusted Types.\n    let suffix = null;\n    const ATTR_NAME = \"data-tt-policy-suffix\";\n    if (purifyHostElement && purifyHostElement.hasAttribute(ATTR_NAME)) {\n        suffix = purifyHostElement.getAttribute(ATTR_NAME);\n    }\n    const policyName = \"dompurify\" + (suffix ? \"#\" + suffix : \"\");\n    try {\n        return trustedTypes.createPolicy(policyName, {\n            createHTML (html) {\n                return html;\n            },\n            createScriptURL (scriptUrl) {\n                return scriptUrl;\n            }\n        });\n    } catch (_) {\n        // Policy creation failed (most likely another DOMPurify script has\n        // already run). Skip creating the policy, as this will only cause errors\n        // if TT are enforced.\n        console.warn(\"TrustedTypes policy \" + policyName + \" could not be created.\");\n        return null;\n    }\n};\nconst _createHooksMap = function _createHooksMap() {\n    return {\n        afterSanitizeAttributes: [],\n        afterSanitizeElements: [],\n        afterSanitizeShadowDOM: [],\n        beforeSanitizeAttributes: [],\n        beforeSanitizeElements: [],\n        beforeSanitizeShadowDOM: [],\n        uponSanitizeAttribute: [],\n        uponSanitizeElement: [],\n        uponSanitizeShadowNode: []\n    };\n};\nfunction createDOMPurify() {\n    let window1 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : getGlobal();\n    const DOMPurify = (root)=>createDOMPurify(root);\n    DOMPurify.version = \"3.2.4\";\n    DOMPurify.removed = [];\n    if (!window1 || !window1.document || window1.document.nodeType !== NODE_TYPE.document || !window1.Element) {\n        // Not running in a browser, provide a factory function\n        // so that you can pass your own Window\n        DOMPurify.isSupported = false;\n        return DOMPurify;\n    }\n    let { document } = window1;\n    const originalDocument = document;\n    const currentScript = originalDocument.currentScript;\n    const { DocumentFragment, HTMLTemplateElement, Node, Element, NodeFilter, NamedNodeMap = window1.NamedNodeMap || window1.MozNamedAttrMap, HTMLFormElement, DOMParser, trustedTypes } = window1;\n    const ElementPrototype = Element.prototype;\n    const cloneNode = lookupGetter(ElementPrototype, \"cloneNode\");\n    const remove = lookupGetter(ElementPrototype, \"remove\");\n    const getNextSibling = lookupGetter(ElementPrototype, \"nextSibling\");\n    const getChildNodes = lookupGetter(ElementPrototype, \"childNodes\");\n    const getParentNode = lookupGetter(ElementPrototype, \"parentNode\");\n    // As per issue #47, the web-components registry is inherited by a\n    // new document created via createHTMLDocument. As per the spec\n    // (http://w3c.github.io/webcomponents/spec/custom/#creating-and-passing-registries)\n    // a new empty registry is used when creating a template contents owner\n    // document, so we use that as our parent document to ensure nothing\n    // is inherited.\n    if (typeof HTMLTemplateElement === \"function\") {\n        const template = document.createElement(\"template\");\n        if (template.content && template.content.ownerDocument) {\n            document = template.content.ownerDocument;\n        }\n    }\n    let trustedTypesPolicy;\n    let emptyHTML = \"\";\n    const { implementation, createNodeIterator, createDocumentFragment, getElementsByTagName } = document;\n    const { importNode } = originalDocument;\n    let hooks = _createHooksMap();\n    /**\n   * Expose whether this browser supports running the full DOMPurify.\n   */ DOMPurify.isSupported = typeof entries === \"function\" && typeof getParentNode === \"function\" && implementation && implementation.createHTMLDocument !== undefined;\n    const { MUSTACHE_EXPR, ERB_EXPR, TMPLIT_EXPR, DATA_ATTR, ARIA_ATTR, IS_SCRIPT_OR_DATA, ATTR_WHITESPACE, CUSTOM_ELEMENT } = EXPRESSIONS;\n    let { IS_ALLOWED_URI: IS_ALLOWED_URI$1 } = EXPRESSIONS;\n    /**\n   * We consider the elements and attributes below to be safe. Ideally\n   * don't add any new ones but feel free to remove unwanted ones.\n   */ /* allowed element names */ let ALLOWED_TAGS = null;\n    const DEFAULT_ALLOWED_TAGS = addToSet({}, [\n        ...html$1,\n        ...svg$1,\n        ...svgFilters,\n        ...mathMl$1,\n        ...text\n    ]);\n    /* Allowed attribute names */ let ALLOWED_ATTR = null;\n    const DEFAULT_ALLOWED_ATTR = addToSet({}, [\n        ...html,\n        ...svg,\n        ...mathMl,\n        ...xml\n    ]);\n    /*\n   * Configure how DOMPurify should handle custom elements and their attributes as well as customized built-in elements.\n   * @property {RegExp|Function|null} tagNameCheck one of [null, regexPattern, predicate]. Default: `null` (disallow any custom elements)\n   * @property {RegExp|Function|null} attributeNameCheck one of [null, regexPattern, predicate]. Default: `null` (disallow any attributes not on the allow list)\n   * @property {boolean} allowCustomizedBuiltInElements allow custom elements derived from built-ins if they pass CUSTOM_ELEMENT_HANDLING.tagNameCheck. Default: `false`.\n   */ let CUSTOM_ELEMENT_HANDLING = Object.seal(create(null, {\n        tagNameCheck: {\n            writable: true,\n            configurable: false,\n            enumerable: true,\n            value: null\n        },\n        attributeNameCheck: {\n            writable: true,\n            configurable: false,\n            enumerable: true,\n            value: null\n        },\n        allowCustomizedBuiltInElements: {\n            writable: true,\n            configurable: false,\n            enumerable: true,\n            value: false\n        }\n    }));\n    /* Explicitly forbidden tags (overrides ALLOWED_TAGS/ADD_TAGS) */ let FORBID_TAGS = null;\n    /* Explicitly forbidden attributes (overrides ALLOWED_ATTR/ADD_ATTR) */ let FORBID_ATTR = null;\n    /* Decide if ARIA attributes are okay */ let ALLOW_ARIA_ATTR = true;\n    /* Decide if custom data attributes are okay */ let ALLOW_DATA_ATTR = true;\n    /* Decide if unknown protocols are okay */ let ALLOW_UNKNOWN_PROTOCOLS = false;\n    /* Decide if self-closing tags in attributes are allowed.\n   * Usually removed due to a mXSS issue in jQuery 3.0 */ let ALLOW_SELF_CLOSE_IN_ATTR = true;\n    /* Output should be safe for common template engines.\n   * This means, DOMPurify removes data attributes, mustaches and ERB\n   */ let SAFE_FOR_TEMPLATES = false;\n    /* Output should be safe even for XML used within HTML and alike.\n   * This means, DOMPurify removes comments when containing risky content.\n   */ let SAFE_FOR_XML = true;\n    /* Decide if document with <html>... should be returned */ let WHOLE_DOCUMENT = false;\n    /* Track whether config is already set on this instance of DOMPurify. */ let SET_CONFIG = false;\n    /* Decide if all elements (e.g. style, script) must be children of\n   * document.body. By default, browsers might move them to document.head */ let FORCE_BODY = false;\n    /* Decide if a DOM `HTMLBodyElement` should be returned, instead of a html\n   * string (or a TrustedHTML object if Trusted Types are supported).\n   * If `WHOLE_DOCUMENT` is enabled a `HTMLHtmlElement` will be returned instead\n   */ let RETURN_DOM = false;\n    /* Decide if a DOM `DocumentFragment` should be returned, instead of a html\n   * string  (or a TrustedHTML object if Trusted Types are supported) */ let RETURN_DOM_FRAGMENT = false;\n    /* Try to return a Trusted Type object instead of a string, return a string in\n   * case Trusted Types are not supported  */ let RETURN_TRUSTED_TYPE = false;\n    /* Output should be free from DOM clobbering attacks?\n   * This sanitizes markups named with colliding, clobberable built-in DOM APIs.\n   */ let SANITIZE_DOM = true;\n    /* Achieve full DOM Clobbering protection by isolating the namespace of named\n   * properties and JS variables, mitigating attacks that abuse the HTML/DOM spec rules.\n   *\n   * HTML/DOM spec rules that enable DOM Clobbering:\n   *   - Named Access on Window (§7.3.3)\n   *   - DOM Tree Accessors (§3.1.5)\n   *   - Form Element Parent-Child Relations (§4.10.3)\n   *   - Iframe srcdoc / Nested WindowProxies (§4.8.5)\n   *   - HTMLCollection (§4.2.10.2)\n   *\n   * Namespace isolation is implemented by prefixing `id` and `name` attributes\n   * with a constant string, i.e., `user-content-`\n   */ let SANITIZE_NAMED_PROPS = false;\n    const SANITIZE_NAMED_PROPS_PREFIX = \"user-content-\";\n    /* Keep element content when removing element? */ let KEEP_CONTENT = true;\n    /* If a `Node` is passed to sanitize(), then performs sanitization in-place instead\n   * of importing it into a new Document and returning a sanitized copy */ let IN_PLACE = false;\n    /* Allow usage of profiles like html, svg and mathMl */ let USE_PROFILES = {};\n    /* Tags to ignore content of when KEEP_CONTENT is true */ let FORBID_CONTENTS = null;\n    const DEFAULT_FORBID_CONTENTS = addToSet({}, [\n        \"annotation-xml\",\n        \"audio\",\n        \"colgroup\",\n        \"desc\",\n        \"foreignobject\",\n        \"head\",\n        \"iframe\",\n        \"math\",\n        \"mi\",\n        \"mn\",\n        \"mo\",\n        \"ms\",\n        \"mtext\",\n        \"noembed\",\n        \"noframes\",\n        \"noscript\",\n        \"plaintext\",\n        \"script\",\n        \"style\",\n        \"svg\",\n        \"template\",\n        \"thead\",\n        \"title\",\n        \"video\",\n        \"xmp\"\n    ]);\n    /* Tags that are safe for data: URIs */ let DATA_URI_TAGS = null;\n    const DEFAULT_DATA_URI_TAGS = addToSet({}, [\n        \"audio\",\n        \"video\",\n        \"img\",\n        \"source\",\n        \"image\",\n        \"track\"\n    ]);\n    /* Attributes safe for values like \"javascript:\" */ let URI_SAFE_ATTRIBUTES = null;\n    const DEFAULT_URI_SAFE_ATTRIBUTES = addToSet({}, [\n        \"alt\",\n        \"class\",\n        \"for\",\n        \"id\",\n        \"label\",\n        \"name\",\n        \"pattern\",\n        \"placeholder\",\n        \"role\",\n        \"summary\",\n        \"title\",\n        \"value\",\n        \"style\",\n        \"xmlns\"\n    ]);\n    const MATHML_NAMESPACE = \"http://www.w3.org/1998/Math/MathML\";\n    const SVG_NAMESPACE = \"http://www.w3.org/2000/svg\";\n    const HTML_NAMESPACE = \"http://www.w3.org/1999/xhtml\";\n    /* Document namespace */ let NAMESPACE = HTML_NAMESPACE;\n    let IS_EMPTY_INPUT = false;\n    /* Allowed XHTML+XML namespaces */ let ALLOWED_NAMESPACES = null;\n    const DEFAULT_ALLOWED_NAMESPACES = addToSet({}, [\n        MATHML_NAMESPACE,\n        SVG_NAMESPACE,\n        HTML_NAMESPACE\n    ], stringToString);\n    let MATHML_TEXT_INTEGRATION_POINTS = addToSet({}, [\n        \"mi\",\n        \"mo\",\n        \"mn\",\n        \"ms\",\n        \"mtext\"\n    ]);\n    let HTML_INTEGRATION_POINTS = addToSet({}, [\n        \"annotation-xml\"\n    ]);\n    // Certain elements are allowed in both SVG and HTML\n    // namespace. We need to specify them explicitly\n    // so that they don't get erroneously deleted from\n    // HTML namespace.\n    const COMMON_SVG_AND_HTML_ELEMENTS = addToSet({}, [\n        \"title\",\n        \"style\",\n        \"font\",\n        \"a\",\n        \"script\"\n    ]);\n    /* Parsing of strict XHTML documents */ let PARSER_MEDIA_TYPE = null;\n    const SUPPORTED_PARSER_MEDIA_TYPES = [\n        \"application/xhtml+xml\",\n        \"text/html\"\n    ];\n    const DEFAULT_PARSER_MEDIA_TYPE = \"text/html\";\n    let transformCaseFunc = null;\n    /* Keep a reference to config to pass to hooks */ let CONFIG = null;\n    /* Ideally, do not touch anything below this line */ /* ______________________________________________ */ const formElement = document.createElement(\"form\");\n    const isRegexOrFunction = function isRegexOrFunction(testValue) {\n        return testValue instanceof RegExp || testValue instanceof Function;\n    };\n    /**\n   * _parseConfig\n   *\n   * @param cfg optional config literal\n   */ // eslint-disable-next-line complexity\n    const _parseConfig = function _parseConfig() {\n        let cfg = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n        if (CONFIG && CONFIG === cfg) {\n            return;\n        }\n        /* Shield configuration object from tampering */ if (!cfg || typeof cfg !== \"object\") {\n            cfg = {};\n        }\n        /* Shield configuration object from prototype pollution */ cfg = clone(cfg);\n        PARSER_MEDIA_TYPE = // eslint-disable-next-line unicorn/prefer-includes\n        SUPPORTED_PARSER_MEDIA_TYPES.indexOf(cfg.PARSER_MEDIA_TYPE) === -1 ? DEFAULT_PARSER_MEDIA_TYPE : cfg.PARSER_MEDIA_TYPE;\n        // HTML tags and attributes are not case-sensitive, converting to lowercase. Keeping XHTML as is.\n        transformCaseFunc = PARSER_MEDIA_TYPE === \"application/xhtml+xml\" ? stringToString : stringToLowerCase;\n        /* Set configuration parameters */ ALLOWED_TAGS = objectHasOwnProperty(cfg, \"ALLOWED_TAGS\") ? addToSet({}, cfg.ALLOWED_TAGS, transformCaseFunc) : DEFAULT_ALLOWED_TAGS;\n        ALLOWED_ATTR = objectHasOwnProperty(cfg, \"ALLOWED_ATTR\") ? addToSet({}, cfg.ALLOWED_ATTR, transformCaseFunc) : DEFAULT_ALLOWED_ATTR;\n        ALLOWED_NAMESPACES = objectHasOwnProperty(cfg, \"ALLOWED_NAMESPACES\") ? addToSet({}, cfg.ALLOWED_NAMESPACES, stringToString) : DEFAULT_ALLOWED_NAMESPACES;\n        URI_SAFE_ATTRIBUTES = objectHasOwnProperty(cfg, \"ADD_URI_SAFE_ATTR\") ? addToSet(clone(DEFAULT_URI_SAFE_ATTRIBUTES), cfg.ADD_URI_SAFE_ATTR, transformCaseFunc) : DEFAULT_URI_SAFE_ATTRIBUTES;\n        DATA_URI_TAGS = objectHasOwnProperty(cfg, \"ADD_DATA_URI_TAGS\") ? addToSet(clone(DEFAULT_DATA_URI_TAGS), cfg.ADD_DATA_URI_TAGS, transformCaseFunc) : DEFAULT_DATA_URI_TAGS;\n        FORBID_CONTENTS = objectHasOwnProperty(cfg, \"FORBID_CONTENTS\") ? addToSet({}, cfg.FORBID_CONTENTS, transformCaseFunc) : DEFAULT_FORBID_CONTENTS;\n        FORBID_TAGS = objectHasOwnProperty(cfg, \"FORBID_TAGS\") ? addToSet({}, cfg.FORBID_TAGS, transformCaseFunc) : {};\n        FORBID_ATTR = objectHasOwnProperty(cfg, \"FORBID_ATTR\") ? addToSet({}, cfg.FORBID_ATTR, transformCaseFunc) : {};\n        USE_PROFILES = objectHasOwnProperty(cfg, \"USE_PROFILES\") ? cfg.USE_PROFILES : false;\n        ALLOW_ARIA_ATTR = cfg.ALLOW_ARIA_ATTR !== false; // Default true\n        ALLOW_DATA_ATTR = cfg.ALLOW_DATA_ATTR !== false; // Default true\n        ALLOW_UNKNOWN_PROTOCOLS = cfg.ALLOW_UNKNOWN_PROTOCOLS || false; // Default false\n        ALLOW_SELF_CLOSE_IN_ATTR = cfg.ALLOW_SELF_CLOSE_IN_ATTR !== false; // Default true\n        SAFE_FOR_TEMPLATES = cfg.SAFE_FOR_TEMPLATES || false; // Default false\n        SAFE_FOR_XML = cfg.SAFE_FOR_XML !== false; // Default true\n        WHOLE_DOCUMENT = cfg.WHOLE_DOCUMENT || false; // Default false\n        RETURN_DOM = cfg.RETURN_DOM || false; // Default false\n        RETURN_DOM_FRAGMENT = cfg.RETURN_DOM_FRAGMENT || false; // Default false\n        RETURN_TRUSTED_TYPE = cfg.RETURN_TRUSTED_TYPE || false; // Default false\n        FORCE_BODY = cfg.FORCE_BODY || false; // Default false\n        SANITIZE_DOM = cfg.SANITIZE_DOM !== false; // Default true\n        SANITIZE_NAMED_PROPS = cfg.SANITIZE_NAMED_PROPS || false; // Default false\n        KEEP_CONTENT = cfg.KEEP_CONTENT !== false; // Default true\n        IN_PLACE = cfg.IN_PLACE || false; // Default false\n        IS_ALLOWED_URI$1 = cfg.ALLOWED_URI_REGEXP || IS_ALLOWED_URI;\n        NAMESPACE = cfg.NAMESPACE || HTML_NAMESPACE;\n        MATHML_TEXT_INTEGRATION_POINTS = cfg.MATHML_TEXT_INTEGRATION_POINTS || MATHML_TEXT_INTEGRATION_POINTS;\n        HTML_INTEGRATION_POINTS = cfg.HTML_INTEGRATION_POINTS || HTML_INTEGRATION_POINTS;\n        CUSTOM_ELEMENT_HANDLING = cfg.CUSTOM_ELEMENT_HANDLING || {};\n        if (cfg.CUSTOM_ELEMENT_HANDLING && isRegexOrFunction(cfg.CUSTOM_ELEMENT_HANDLING.tagNameCheck)) {\n            CUSTOM_ELEMENT_HANDLING.tagNameCheck = cfg.CUSTOM_ELEMENT_HANDLING.tagNameCheck;\n        }\n        if (cfg.CUSTOM_ELEMENT_HANDLING && isRegexOrFunction(cfg.CUSTOM_ELEMENT_HANDLING.attributeNameCheck)) {\n            CUSTOM_ELEMENT_HANDLING.attributeNameCheck = cfg.CUSTOM_ELEMENT_HANDLING.attributeNameCheck;\n        }\n        if (cfg.CUSTOM_ELEMENT_HANDLING && typeof cfg.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements === \"boolean\") {\n            CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements = cfg.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements;\n        }\n        if (SAFE_FOR_TEMPLATES) {\n            ALLOW_DATA_ATTR = false;\n        }\n        if (RETURN_DOM_FRAGMENT) {\n            RETURN_DOM = true;\n        }\n        /* Parse profile info */ if (USE_PROFILES) {\n            ALLOWED_TAGS = addToSet({}, text);\n            ALLOWED_ATTR = [];\n            if (USE_PROFILES.html === true) {\n                addToSet(ALLOWED_TAGS, html$1);\n                addToSet(ALLOWED_ATTR, html);\n            }\n            if (USE_PROFILES.svg === true) {\n                addToSet(ALLOWED_TAGS, svg$1);\n                addToSet(ALLOWED_ATTR, svg);\n                addToSet(ALLOWED_ATTR, xml);\n            }\n            if (USE_PROFILES.svgFilters === true) {\n                addToSet(ALLOWED_TAGS, svgFilters);\n                addToSet(ALLOWED_ATTR, svg);\n                addToSet(ALLOWED_ATTR, xml);\n            }\n            if (USE_PROFILES.mathMl === true) {\n                addToSet(ALLOWED_TAGS, mathMl$1);\n                addToSet(ALLOWED_ATTR, mathMl);\n                addToSet(ALLOWED_ATTR, xml);\n            }\n        }\n        /* Merge configuration parameters */ if (cfg.ADD_TAGS) {\n            if (ALLOWED_TAGS === DEFAULT_ALLOWED_TAGS) {\n                ALLOWED_TAGS = clone(ALLOWED_TAGS);\n            }\n            addToSet(ALLOWED_TAGS, cfg.ADD_TAGS, transformCaseFunc);\n        }\n        if (cfg.ADD_ATTR) {\n            if (ALLOWED_ATTR === DEFAULT_ALLOWED_ATTR) {\n                ALLOWED_ATTR = clone(ALLOWED_ATTR);\n            }\n            addToSet(ALLOWED_ATTR, cfg.ADD_ATTR, transformCaseFunc);\n        }\n        if (cfg.ADD_URI_SAFE_ATTR) {\n            addToSet(URI_SAFE_ATTRIBUTES, cfg.ADD_URI_SAFE_ATTR, transformCaseFunc);\n        }\n        if (cfg.FORBID_CONTENTS) {\n            if (FORBID_CONTENTS === DEFAULT_FORBID_CONTENTS) {\n                FORBID_CONTENTS = clone(FORBID_CONTENTS);\n            }\n            addToSet(FORBID_CONTENTS, cfg.FORBID_CONTENTS, transformCaseFunc);\n        }\n        /* Add #text in case KEEP_CONTENT is set to true */ if (KEEP_CONTENT) {\n            ALLOWED_TAGS[\"#text\"] = true;\n        }\n        /* Add html, head and body to ALLOWED_TAGS in case WHOLE_DOCUMENT is true */ if (WHOLE_DOCUMENT) {\n            addToSet(ALLOWED_TAGS, [\n                \"html\",\n                \"head\",\n                \"body\"\n            ]);\n        }\n        /* Add tbody to ALLOWED_TAGS in case tables are permitted, see #286, #365 */ if (ALLOWED_TAGS.table) {\n            addToSet(ALLOWED_TAGS, [\n                \"tbody\"\n            ]);\n            delete FORBID_TAGS.tbody;\n        }\n        if (cfg.TRUSTED_TYPES_POLICY) {\n            if (typeof cfg.TRUSTED_TYPES_POLICY.createHTML !== \"function\") {\n                throw typeErrorCreate('TRUSTED_TYPES_POLICY configuration option must provide a \"createHTML\" hook.');\n            }\n            if (typeof cfg.TRUSTED_TYPES_POLICY.createScriptURL !== \"function\") {\n                throw typeErrorCreate('TRUSTED_TYPES_POLICY configuration option must provide a \"createScriptURL\" hook.');\n            }\n            // Overwrite existing TrustedTypes policy.\n            trustedTypesPolicy = cfg.TRUSTED_TYPES_POLICY;\n            // Sign local variables required by `sanitize`.\n            emptyHTML = trustedTypesPolicy.createHTML(\"\");\n        } else {\n            // Uninitialized policy, attempt to initialize the internal dompurify policy.\n            if (trustedTypesPolicy === undefined) {\n                trustedTypesPolicy = _createTrustedTypesPolicy(trustedTypes, currentScript);\n            }\n            // If creating the internal policy succeeded sign internal variables.\n            if (trustedTypesPolicy !== null && typeof emptyHTML === \"string\") {\n                emptyHTML = trustedTypesPolicy.createHTML(\"\");\n            }\n        }\n        // Prevent further manipulation of configuration.\n        // Not available in IE8, Safari 5, etc.\n        if (freeze) {\n            freeze(cfg);\n        }\n        CONFIG = cfg;\n    };\n    /* Keep track of all possible SVG and MathML tags\n   * so that we can perform the namespace checks\n   * correctly. */ const ALL_SVG_TAGS = addToSet({}, [\n        ...svg$1,\n        ...svgFilters,\n        ...svgDisallowed\n    ]);\n    const ALL_MATHML_TAGS = addToSet({}, [\n        ...mathMl$1,\n        ...mathMlDisallowed\n    ]);\n    /**\n   * @param element a DOM element whose namespace is being checked\n   * @returns Return false if the element has a\n   *  namespace that a spec-compliant parser would never\n   *  return. Return true otherwise.\n   */ const _checkValidNamespace = function _checkValidNamespace(element) {\n        let parent = getParentNode(element);\n        // In JSDOM, if we're inside shadow DOM, then parentNode\n        // can be null. We just simulate parent in this case.\n        if (!parent || !parent.tagName) {\n            parent = {\n                namespaceURI: NAMESPACE,\n                tagName: \"template\"\n            };\n        }\n        const tagName = stringToLowerCase(element.tagName);\n        const parentTagName = stringToLowerCase(parent.tagName);\n        if (!ALLOWED_NAMESPACES[element.namespaceURI]) {\n            return false;\n        }\n        if (element.namespaceURI === SVG_NAMESPACE) {\n            // The only way to switch from HTML namespace to SVG\n            // is via <svg>. If it happens via any other tag, then\n            // it should be killed.\n            if (parent.namespaceURI === HTML_NAMESPACE) {\n                return tagName === \"svg\";\n            }\n            // The only way to switch from MathML to SVG is via`\n            // svg if parent is either <annotation-xml> or MathML\n            // text integration points.\n            if (parent.namespaceURI === MATHML_NAMESPACE) {\n                return tagName === \"svg\" && (parentTagName === \"annotation-xml\" || MATHML_TEXT_INTEGRATION_POINTS[parentTagName]);\n            }\n            // We only allow elements that are defined in SVG\n            // spec. All others are disallowed in SVG namespace.\n            return Boolean(ALL_SVG_TAGS[tagName]);\n        }\n        if (element.namespaceURI === MATHML_NAMESPACE) {\n            // The only way to switch from HTML namespace to MathML\n            // is via <math>. If it happens via any other tag, then\n            // it should be killed.\n            if (parent.namespaceURI === HTML_NAMESPACE) {\n                return tagName === \"math\";\n            }\n            // The only way to switch from SVG to MathML is via\n            // <math> and HTML integration points\n            if (parent.namespaceURI === SVG_NAMESPACE) {\n                return tagName === \"math\" && HTML_INTEGRATION_POINTS[parentTagName];\n            }\n            // We only allow elements that are defined in MathML\n            // spec. All others are disallowed in MathML namespace.\n            return Boolean(ALL_MATHML_TAGS[tagName]);\n        }\n        if (element.namespaceURI === HTML_NAMESPACE) {\n            // The only way to switch from SVG to HTML is via\n            // HTML integration points, and from MathML to HTML\n            // is via MathML text integration points\n            if (parent.namespaceURI === SVG_NAMESPACE && !HTML_INTEGRATION_POINTS[parentTagName]) {\n                return false;\n            }\n            if (parent.namespaceURI === MATHML_NAMESPACE && !MATHML_TEXT_INTEGRATION_POINTS[parentTagName]) {\n                return false;\n            }\n            // We disallow tags that are specific for MathML\n            // or SVG and should never appear in HTML namespace\n            return !ALL_MATHML_TAGS[tagName] && (COMMON_SVG_AND_HTML_ELEMENTS[tagName] || !ALL_SVG_TAGS[tagName]);\n        }\n        // For XHTML and XML documents that support custom namespaces\n        if (PARSER_MEDIA_TYPE === \"application/xhtml+xml\" && ALLOWED_NAMESPACES[element.namespaceURI]) {\n            return true;\n        }\n        // The code should never reach this place (this means\n        // that the element somehow got namespace that is not\n        // HTML, SVG, MathML or allowed via ALLOWED_NAMESPACES).\n        // Return false just in case.\n        return false;\n    };\n    /**\n   * _forceRemove\n   *\n   * @param node a DOM node\n   */ const _forceRemove = function _forceRemove(node) {\n        arrayPush(DOMPurify.removed, {\n            element: node\n        });\n        try {\n            // eslint-disable-next-line unicorn/prefer-dom-node-remove\n            getParentNode(node).removeChild(node);\n        } catch (_) {\n            remove(node);\n        }\n    };\n    /**\n   * _removeAttribute\n   *\n   * @param name an Attribute name\n   * @param element a DOM node\n   */ const _removeAttribute = function _removeAttribute(name, element) {\n        try {\n            arrayPush(DOMPurify.removed, {\n                attribute: element.getAttributeNode(name),\n                from: element\n            });\n        } catch (_) {\n            arrayPush(DOMPurify.removed, {\n                attribute: null,\n                from: element\n            });\n        }\n        element.removeAttribute(name);\n        // We void attribute values for unremovable \"is\" attributes\n        if (name === \"is\") {\n            if (RETURN_DOM || RETURN_DOM_FRAGMENT) {\n                try {\n                    _forceRemove(element);\n                } catch (_) {}\n            } else {\n                try {\n                    element.setAttribute(name, \"\");\n                } catch (_) {}\n            }\n        }\n    };\n    /**\n   * _initDocument\n   *\n   * @param dirty - a string of dirty markup\n   * @return a DOM, filled with the dirty markup\n   */ const _initDocument = function _initDocument(dirty) {\n        /* Create a HTML document */ let doc = null;\n        let leadingWhitespace = null;\n        if (FORCE_BODY) {\n            dirty = \"<remove></remove>\" + dirty;\n        } else {\n            /* If FORCE_BODY isn't used, leading whitespace needs to be preserved manually */ const matches = stringMatch(dirty, /^[\\r\\n\\t ]+/);\n            leadingWhitespace = matches && matches[0];\n        }\n        if (PARSER_MEDIA_TYPE === \"application/xhtml+xml\" && NAMESPACE === HTML_NAMESPACE) {\n            // Root of XHTML doc must contain xmlns declaration (see https://www.w3.org/TR/xhtml1/normative.html#strict)\n            dirty = '<html xmlns=\"http://www.w3.org/1999/xhtml\"><head></head><body>' + dirty + \"</body></html>\";\n        }\n        const dirtyPayload = trustedTypesPolicy ? trustedTypesPolicy.createHTML(dirty) : dirty;\n        /*\n     * Use the DOMParser API by default, fallback later if needs be\n     * DOMParser not work for svg when has multiple root element.\n     */ if (NAMESPACE === HTML_NAMESPACE) {\n            try {\n                doc = new DOMParser().parseFromString(dirtyPayload, PARSER_MEDIA_TYPE);\n            } catch (_) {}\n        }\n        /* Use createHTMLDocument in case DOMParser is not available */ if (!doc || !doc.documentElement) {\n            doc = implementation.createDocument(NAMESPACE, \"template\", null);\n            try {\n                doc.documentElement.innerHTML = IS_EMPTY_INPUT ? emptyHTML : dirtyPayload;\n            } catch (_) {\n            // Syntax error if dirtyPayload is invalid xml\n            }\n        }\n        const body = doc.body || doc.documentElement;\n        if (dirty && leadingWhitespace) {\n            body.insertBefore(document.createTextNode(leadingWhitespace), body.childNodes[0] || null);\n        }\n        /* Work on whole document or just its body */ if (NAMESPACE === HTML_NAMESPACE) {\n            return getElementsByTagName.call(doc, WHOLE_DOCUMENT ? \"html\" : \"body\")[0];\n        }\n        return WHOLE_DOCUMENT ? doc.documentElement : body;\n    };\n    /**\n   * Creates a NodeIterator object that you can use to traverse filtered lists of nodes or elements in a document.\n   *\n   * @param root The root element or node to start traversing on.\n   * @return The created NodeIterator\n   */ const _createNodeIterator = function _createNodeIterator(root) {\n        return createNodeIterator.call(root.ownerDocument || root, root, // eslint-disable-next-line no-bitwise\n        NodeFilter.SHOW_ELEMENT | NodeFilter.SHOW_COMMENT | NodeFilter.SHOW_TEXT | NodeFilter.SHOW_PROCESSING_INSTRUCTION | NodeFilter.SHOW_CDATA_SECTION, null);\n    };\n    /**\n   * _isClobbered\n   *\n   * @param element element to check for clobbering attacks\n   * @return true if clobbered, false if safe\n   */ const _isClobbered = function _isClobbered(element) {\n        return element instanceof HTMLFormElement && (typeof element.nodeName !== \"string\" || typeof element.textContent !== \"string\" || typeof element.removeChild !== \"function\" || !(element.attributes instanceof NamedNodeMap) || typeof element.removeAttribute !== \"function\" || typeof element.setAttribute !== \"function\" || typeof element.namespaceURI !== \"string\" || typeof element.insertBefore !== \"function\" || typeof element.hasChildNodes !== \"function\");\n    };\n    /**\n   * Checks whether the given object is a DOM node.\n   *\n   * @param value object to check whether it's a DOM node\n   * @return true is object is a DOM node\n   */ const _isNode = function _isNode(value) {\n        return typeof Node === \"function\" && value instanceof Node;\n    };\n    function _executeHooks(hooks, currentNode, data) {\n        arrayForEach(hooks, (hook)=>{\n            hook.call(DOMPurify, currentNode, data, CONFIG);\n        });\n    }\n    /**\n   * _sanitizeElements\n   *\n   * @protect nodeName\n   * @protect textContent\n   * @protect removeChild\n   * @param currentNode to check for permission to exist\n   * @return true if node was killed, false if left alive\n   */ const _sanitizeElements = function _sanitizeElements(currentNode) {\n        let content = null;\n        /* Execute a hook if present */ _executeHooks(hooks.beforeSanitizeElements, currentNode, null);\n        /* Check if element is clobbered or can clobber */ if (_isClobbered(currentNode)) {\n            _forceRemove(currentNode);\n            return true;\n        }\n        /* Now let's check the element's type and name */ const tagName = transformCaseFunc(currentNode.nodeName);\n        /* Execute a hook if present */ _executeHooks(hooks.uponSanitizeElement, currentNode, {\n            tagName,\n            allowedTags: ALLOWED_TAGS\n        });\n        /* Detect mXSS attempts abusing namespace confusion */ if (currentNode.hasChildNodes() && !_isNode(currentNode.firstElementChild) && regExpTest(/<[/\\w]/g, currentNode.innerHTML) && regExpTest(/<[/\\w]/g, currentNode.textContent)) {\n            _forceRemove(currentNode);\n            return true;\n        }\n        /* Remove any occurrence of processing instructions */ if (currentNode.nodeType === NODE_TYPE.progressingInstruction) {\n            _forceRemove(currentNode);\n            return true;\n        }\n        /* Remove any kind of possibly harmful comments */ if (SAFE_FOR_XML && currentNode.nodeType === NODE_TYPE.comment && regExpTest(/<[/\\w]/g, currentNode.data)) {\n            _forceRemove(currentNode);\n            return true;\n        }\n        /* Remove element if anything forbids its presence */ if (!ALLOWED_TAGS[tagName] || FORBID_TAGS[tagName]) {\n            /* Check if we have a custom element to handle */ if (!FORBID_TAGS[tagName] && _isBasicCustomElement(tagName)) {\n                if (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.tagNameCheck, tagName)) {\n                    return false;\n                }\n                if (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.tagNameCheck(tagName)) {\n                    return false;\n                }\n            }\n            /* Keep content except for bad-listed elements */ if (KEEP_CONTENT && !FORBID_CONTENTS[tagName]) {\n                const parentNode = getParentNode(currentNode) || currentNode.parentNode;\n                const childNodes = getChildNodes(currentNode) || currentNode.childNodes;\n                if (childNodes && parentNode) {\n                    const childCount = childNodes.length;\n                    for(let i = childCount - 1; i >= 0; --i){\n                        const childClone = cloneNode(childNodes[i], true);\n                        childClone.__removalCount = (currentNode.__removalCount || 0) + 1;\n                        parentNode.insertBefore(childClone, getNextSibling(currentNode));\n                    }\n                }\n            }\n            _forceRemove(currentNode);\n            return true;\n        }\n        /* Check whether element has a valid namespace */ if (currentNode instanceof Element && !_checkValidNamespace(currentNode)) {\n            _forceRemove(currentNode);\n            return true;\n        }\n        /* Make sure that older browsers don't get fallback-tag mXSS */ if ((tagName === \"noscript\" || tagName === \"noembed\" || tagName === \"noframes\") && regExpTest(/<\\/no(script|embed|frames)/i, currentNode.innerHTML)) {\n            _forceRemove(currentNode);\n            return true;\n        }\n        /* Sanitize element content to be template-safe */ if (SAFE_FOR_TEMPLATES && currentNode.nodeType === NODE_TYPE.text) {\n            /* Get the element's text content */ content = currentNode.textContent;\n            arrayForEach([\n                MUSTACHE_EXPR,\n                ERB_EXPR,\n                TMPLIT_EXPR\n            ], (expr)=>{\n                content = stringReplace(content, expr, \" \");\n            });\n            if (currentNode.textContent !== content) {\n                arrayPush(DOMPurify.removed, {\n                    element: currentNode.cloneNode()\n                });\n                currentNode.textContent = content;\n            }\n        }\n        /* Execute a hook if present */ _executeHooks(hooks.afterSanitizeElements, currentNode, null);\n        return false;\n    };\n    /**\n   * _isValidAttribute\n   *\n   * @param lcTag Lowercase tag name of containing element.\n   * @param lcName Lowercase attribute name.\n   * @param value Attribute value.\n   * @return Returns true if `value` is valid, otherwise false.\n   */ // eslint-disable-next-line complexity\n    const _isValidAttribute = function _isValidAttribute(lcTag, lcName, value) {\n        /* Make sure attribute cannot clobber */ if (SANITIZE_DOM && (lcName === \"id\" || lcName === \"name\") && (value in document || value in formElement)) {\n            return false;\n        }\n        /* Allow valid data-* attributes: At least one character after \"-\"\n        (https://html.spec.whatwg.org/multipage/dom.html#embedding-custom-non-visible-data-with-the-data-*-attributes)\n        XML-compatible (https://html.spec.whatwg.org/multipage/infrastructure.html#xml-compatible and http://www.w3.org/TR/xml/#d0e804)\n        We don't need to check the value; it's always URI safe. */ if (ALLOW_DATA_ATTR && !FORBID_ATTR[lcName] && regExpTest(DATA_ATTR, lcName)) ;\n        else if (ALLOW_ARIA_ATTR && regExpTest(ARIA_ATTR, lcName)) ;\n        else if (!ALLOWED_ATTR[lcName] || FORBID_ATTR[lcName]) {\n            if (// First condition does a very basic check if a) it's basically a valid custom element tagname AND\n            // b) if the tagName passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.tagNameCheck\n            // and c) if the attribute name passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.attributeNameCheck\n            _isBasicCustomElement(lcTag) && (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.tagNameCheck, lcTag) || CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.tagNameCheck(lcTag)) && (CUSTOM_ELEMENT_HANDLING.attributeNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.attributeNameCheck, lcName) || CUSTOM_ELEMENT_HANDLING.attributeNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.attributeNameCheck(lcName)) || // Alternative, second condition checks if it's an `is`-attribute, AND\n            // the value passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.tagNameCheck\n            lcName === \"is\" && CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements && (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.tagNameCheck, value) || CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.tagNameCheck(value))) ;\n            else {\n                return false;\n            }\n        /* Check value is safe. First, is attr inert? If so, is safe */ } else if (URI_SAFE_ATTRIBUTES[lcName]) ;\n        else if (regExpTest(IS_ALLOWED_URI$1, stringReplace(value, ATTR_WHITESPACE, \"\"))) ;\n        else if ((lcName === \"src\" || lcName === \"xlink:href\" || lcName === \"href\") && lcTag !== \"script\" && stringIndexOf(value, \"data:\") === 0 && DATA_URI_TAGS[lcTag]) ;\n        else if (ALLOW_UNKNOWN_PROTOCOLS && !regExpTest(IS_SCRIPT_OR_DATA, stringReplace(value, ATTR_WHITESPACE, \"\"))) ;\n        else if (value) {\n            return false;\n        } else ;\n        return true;\n    };\n    /**\n   * _isBasicCustomElement\n   * checks if at least one dash is included in tagName, and it's not the first char\n   * for more sophisticated checking see https://github.com/sindresorhus/validate-element-name\n   *\n   * @param tagName name of the tag of the node to sanitize\n   * @returns Returns true if the tag name meets the basic criteria for a custom element, otherwise false.\n   */ const _isBasicCustomElement = function _isBasicCustomElement(tagName) {\n        return tagName !== \"annotation-xml\" && stringMatch(tagName, CUSTOM_ELEMENT);\n    };\n    /**\n   * _sanitizeAttributes\n   *\n   * @protect attributes\n   * @protect nodeName\n   * @protect removeAttribute\n   * @protect setAttribute\n   *\n   * @param currentNode to sanitize\n   */ const _sanitizeAttributes = function _sanitizeAttributes(currentNode) {\n        /* Execute a hook if present */ _executeHooks(hooks.beforeSanitizeAttributes, currentNode, null);\n        const { attributes } = currentNode;\n        /* Check if we have attributes; if not we might have a text node */ if (!attributes || _isClobbered(currentNode)) {\n            return;\n        }\n        const hookEvent = {\n            attrName: \"\",\n            attrValue: \"\",\n            keepAttr: true,\n            allowedAttributes: ALLOWED_ATTR,\n            forceKeepAttr: undefined\n        };\n        let l = attributes.length;\n        /* Go backwards over all attributes; safely remove bad ones */ while(l--){\n            const attr = attributes[l];\n            const { name, namespaceURI, value: attrValue } = attr;\n            const lcName = transformCaseFunc(name);\n            let value = name === \"value\" ? attrValue : stringTrim(attrValue);\n            /* Execute a hook if present */ hookEvent.attrName = lcName;\n            hookEvent.attrValue = value;\n            hookEvent.keepAttr = true;\n            hookEvent.forceKeepAttr = undefined; // Allows developers to see this is a property they can set\n            _executeHooks(hooks.uponSanitizeAttribute, currentNode, hookEvent);\n            value = hookEvent.attrValue;\n            /* Full DOM Clobbering protection via namespace isolation,\n       * Prefix id and name attributes with `user-content-`\n       */ if (SANITIZE_NAMED_PROPS && (lcName === \"id\" || lcName === \"name\")) {\n                // Remove the attribute with this value\n                _removeAttribute(name, currentNode);\n                // Prefix the value and later re-create the attribute with the sanitized value\n                value = SANITIZE_NAMED_PROPS_PREFIX + value;\n            }\n            /* Work around a security issue with comments inside attributes */ if (SAFE_FOR_XML && regExpTest(/((--!?|])>)|<\\/(style|title)/i, value)) {\n                _removeAttribute(name, currentNode);\n                continue;\n            }\n            /* Did the hooks approve of the attribute? */ if (hookEvent.forceKeepAttr) {\n                continue;\n            }\n            /* Remove attribute */ _removeAttribute(name, currentNode);\n            /* Did the hooks approve of the attribute? */ if (!hookEvent.keepAttr) {\n                continue;\n            }\n            /* Work around a security issue in jQuery 3.0 */ if (!ALLOW_SELF_CLOSE_IN_ATTR && regExpTest(/\\/>/i, value)) {\n                _removeAttribute(name, currentNode);\n                continue;\n            }\n            /* Sanitize attribute content to be template-safe */ if (SAFE_FOR_TEMPLATES) {\n                arrayForEach([\n                    MUSTACHE_EXPR,\n                    ERB_EXPR,\n                    TMPLIT_EXPR\n                ], (expr)=>{\n                    value = stringReplace(value, expr, \" \");\n                });\n            }\n            /* Is `value` valid for this attribute? */ const lcTag = transformCaseFunc(currentNode.nodeName);\n            if (!_isValidAttribute(lcTag, lcName, value)) {\n                continue;\n            }\n            /* Handle attributes that require Trusted Types */ if (trustedTypesPolicy && typeof trustedTypes === \"object\" && typeof trustedTypes.getAttributeType === \"function\") {\n                if (namespaceURI) ;\n                else {\n                    switch(trustedTypes.getAttributeType(lcTag, lcName)){\n                        case \"TrustedHTML\":\n                            {\n                                value = trustedTypesPolicy.createHTML(value);\n                                break;\n                            }\n                        case \"TrustedScriptURL\":\n                            {\n                                value = trustedTypesPolicy.createScriptURL(value);\n                                break;\n                            }\n                    }\n                }\n            }\n            /* Handle invalid data-* attribute set by try-catching it */ try {\n                if (namespaceURI) {\n                    currentNode.setAttributeNS(namespaceURI, name, value);\n                } else {\n                    /* Fallback to setAttribute() for browser-unrecognized namespaces e.g. \"x-schema\". */ currentNode.setAttribute(name, value);\n                }\n                if (_isClobbered(currentNode)) {\n                    _forceRemove(currentNode);\n                } else {\n                    arrayPop(DOMPurify.removed);\n                }\n            } catch (_) {}\n        }\n        /* Execute a hook if present */ _executeHooks(hooks.afterSanitizeAttributes, currentNode, null);\n    };\n    /**\n   * _sanitizeShadowDOM\n   *\n   * @param fragment to iterate over recursively\n   */ const _sanitizeShadowDOM = function _sanitizeShadowDOM(fragment) {\n        let shadowNode = null;\n        const shadowIterator = _createNodeIterator(fragment);\n        /* Execute a hook if present */ _executeHooks(hooks.beforeSanitizeShadowDOM, fragment, null);\n        while(shadowNode = shadowIterator.nextNode()){\n            /* Execute a hook if present */ _executeHooks(hooks.uponSanitizeShadowNode, shadowNode, null);\n            /* Sanitize tags and elements */ _sanitizeElements(shadowNode);\n            /* Check attributes next */ _sanitizeAttributes(shadowNode);\n            /* Deep shadow DOM detected */ if (shadowNode.content instanceof DocumentFragment) {\n                _sanitizeShadowDOM(shadowNode.content);\n            }\n        }\n        /* Execute a hook if present */ _executeHooks(hooks.afterSanitizeShadowDOM, fragment, null);\n    };\n    // eslint-disable-next-line complexity\n    DOMPurify.sanitize = function(dirty) {\n        let cfg = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n        let body = null;\n        let importedNode = null;\n        let currentNode = null;\n        let returnNode = null;\n        /* Make sure we have a string to sanitize.\n      DO NOT return early, as this will return the wrong type if\n      the user has requested a DOM object rather than a string */ IS_EMPTY_INPUT = !dirty;\n        if (IS_EMPTY_INPUT) {\n            dirty = \"<!-->\";\n        }\n        /* Stringify, in case dirty is an object */ if (typeof dirty !== \"string\" && !_isNode(dirty)) {\n            if (typeof dirty.toString === \"function\") {\n                dirty = dirty.toString();\n                if (typeof dirty !== \"string\") {\n                    throw typeErrorCreate(\"dirty is not a string, aborting\");\n                }\n            } else {\n                throw typeErrorCreate(\"toString is not a function\");\n            }\n        }\n        /* Return dirty HTML if DOMPurify cannot run */ if (!DOMPurify.isSupported) {\n            return dirty;\n        }\n        /* Assign config vars */ if (!SET_CONFIG) {\n            _parseConfig(cfg);\n        }\n        /* Clean up removed elements */ DOMPurify.removed = [];\n        /* Check if dirty is correctly typed for IN_PLACE */ if (typeof dirty === \"string\") {\n            IN_PLACE = false;\n        }\n        if (IN_PLACE) {\n            /* Do some early pre-sanitization to avoid unsafe root nodes */ if (dirty.nodeName) {\n                const tagName = transformCaseFunc(dirty.nodeName);\n                if (!ALLOWED_TAGS[tagName] || FORBID_TAGS[tagName]) {\n                    throw typeErrorCreate(\"root node is forbidden and cannot be sanitized in-place\");\n                }\n            }\n        } else if (dirty instanceof Node) {\n            /* If dirty is a DOM element, append to an empty document to avoid\n         elements being stripped by the parser */ body = _initDocument(\"<!---->\");\n            importedNode = body.ownerDocument.importNode(dirty, true);\n            if (importedNode.nodeType === NODE_TYPE.element && importedNode.nodeName === \"BODY\") {\n                /* Node is already a body, use as is */ body = importedNode;\n            } else if (importedNode.nodeName === \"HTML\") {\n                body = importedNode;\n            } else {\n                // eslint-disable-next-line unicorn/prefer-dom-node-append\n                body.appendChild(importedNode);\n            }\n        } else {\n            /* Exit directly if we have nothing to do */ if (!RETURN_DOM && !SAFE_FOR_TEMPLATES && !WHOLE_DOCUMENT && // eslint-disable-next-line unicorn/prefer-includes\n            dirty.indexOf(\"<\") === -1) {\n                return trustedTypesPolicy && RETURN_TRUSTED_TYPE ? trustedTypesPolicy.createHTML(dirty) : dirty;\n            }\n            /* Initialize the document to work on */ body = _initDocument(dirty);\n            /* Check we have a DOM node from the data */ if (!body) {\n                return RETURN_DOM ? null : RETURN_TRUSTED_TYPE ? emptyHTML : \"\";\n            }\n        }\n        /* Remove first element node (ours) if FORCE_BODY is set */ if (body && FORCE_BODY) {\n            _forceRemove(body.firstChild);\n        }\n        /* Get node iterator */ const nodeIterator = _createNodeIterator(IN_PLACE ? dirty : body);\n        /* Now start iterating over the created document */ while(currentNode = nodeIterator.nextNode()){\n            /* Sanitize tags and elements */ _sanitizeElements(currentNode);\n            /* Check attributes next */ _sanitizeAttributes(currentNode);\n            /* Shadow DOM detected, sanitize it */ if (currentNode.content instanceof DocumentFragment) {\n                _sanitizeShadowDOM(currentNode.content);\n            }\n        }\n        /* If we sanitized `dirty` in-place, return it. */ if (IN_PLACE) {\n            return dirty;\n        }\n        /* Return sanitized string or DOM */ if (RETURN_DOM) {\n            if (RETURN_DOM_FRAGMENT) {\n                returnNode = createDocumentFragment.call(body.ownerDocument);\n                while(body.firstChild){\n                    // eslint-disable-next-line unicorn/prefer-dom-node-append\n                    returnNode.appendChild(body.firstChild);\n                }\n            } else {\n                returnNode = body;\n            }\n            if (ALLOWED_ATTR.shadowroot || ALLOWED_ATTR.shadowrootmode) {\n                /*\n          AdoptNode() is not used because internal state is not reset\n          (e.g. the past names map of a HTMLFormElement), this is safe\n          in theory but we would rather not risk another attack vector.\n          The state that is cloned by importNode() is explicitly defined\n          by the specs.\n        */ returnNode = importNode.call(originalDocument, returnNode, true);\n            }\n            return returnNode;\n        }\n        let serializedHTML = WHOLE_DOCUMENT ? body.outerHTML : body.innerHTML;\n        /* Serialize doctype if allowed */ if (WHOLE_DOCUMENT && ALLOWED_TAGS[\"!doctype\"] && body.ownerDocument && body.ownerDocument.doctype && body.ownerDocument.doctype.name && regExpTest(DOCTYPE_NAME, body.ownerDocument.doctype.name)) {\n            serializedHTML = \"<!DOCTYPE \" + body.ownerDocument.doctype.name + \">\\n\" + serializedHTML;\n        }\n        /* Sanitize final string template-safe */ if (SAFE_FOR_TEMPLATES) {\n            arrayForEach([\n                MUSTACHE_EXPR,\n                ERB_EXPR,\n                TMPLIT_EXPR\n            ], (expr)=>{\n                serializedHTML = stringReplace(serializedHTML, expr, \" \");\n            });\n        }\n        return trustedTypesPolicy && RETURN_TRUSTED_TYPE ? trustedTypesPolicy.createHTML(serializedHTML) : serializedHTML;\n    };\n    DOMPurify.setConfig = function() {\n        let cfg = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n        _parseConfig(cfg);\n        SET_CONFIG = true;\n    };\n    DOMPurify.clearConfig = function() {\n        CONFIG = null;\n        SET_CONFIG = false;\n    };\n    DOMPurify.isValidAttribute = function(tag, attr, value) {\n        /* Initialize shared config vars if necessary. */ if (!CONFIG) {\n            _parseConfig({});\n        }\n        const lcTag = transformCaseFunc(tag);\n        const lcName = transformCaseFunc(attr);\n        return _isValidAttribute(lcTag, lcName, value);\n    };\n    DOMPurify.addHook = function(entryPoint, hookFunction) {\n        if (typeof hookFunction !== \"function\") {\n            return;\n        }\n        arrayPush(hooks[entryPoint], hookFunction);\n    };\n    DOMPurify.removeHook = function(entryPoint, hookFunction) {\n        if (hookFunction !== undefined) {\n            const index = arrayLastIndexOf(hooks[entryPoint], hookFunction);\n            return index === -1 ? undefined : arraySplice(hooks[entryPoint], index, 1)[0];\n        }\n        return arrayPop(hooks[entryPoint]);\n    };\n    DOMPurify.removeHooks = function(entryPoint) {\n        hooks[entryPoint] = [];\n    };\n    DOMPurify.removeAllHooks = function() {\n        hooks = _createHooksMap();\n    };\n    return DOMPurify;\n}\nvar purify = createDOMPurify();\n //# sourceMappingURL=purify.es.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZG9tcHVyaWZ5L2Rpc3QvcHVyaWZ5LmVzLm1qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUEseUxBQXlMLEdBRXpMLE1BQU0sRUFDSkEsT0FBTyxFQUNQQyxjQUFjLEVBQ2RDLFFBQVEsRUFDUkMsY0FBYyxFQUNkQyx3QkFBd0IsRUFDekIsR0FBR0M7QUFDSixJQUFJLEVBQ0ZDLE1BQU0sRUFDTkMsSUFBSSxFQUNKQyxNQUFNLEVBQ1AsR0FBR0gsUUFBUSxnREFBZ0Q7QUFDNUQsSUFBSSxFQUNGSSxLQUFLLEVBQ0xDLFNBQVMsRUFDVixHQUFHLE9BQU9DLFlBQVksZUFBZUE7QUFDdEMsSUFBSSxDQUFDTCxRQUFRO0lBQ1hBLFNBQVMsU0FBU0EsT0FBT00sQ0FBQztRQUN4QixPQUFPQTtJQUNUO0FBQ0Y7QUFDQSxJQUFJLENBQUNMLE1BQU07SUFDVEEsT0FBTyxTQUFTQSxLQUFLSyxDQUFDO1FBQ3BCLE9BQU9BO0lBQ1Q7QUFDRjtBQUNBLElBQUksQ0FBQ0gsT0FBTztJQUNWQSxRQUFRLFNBQVNBLE1BQU1JLEdBQUcsRUFBRUMsU0FBUyxFQUFFQyxJQUFJO1FBQ3pDLE9BQU9GLElBQUlKLEtBQUssQ0FBQ0ssV0FBV0M7SUFDOUI7QUFDRjtBQUNBLElBQUksQ0FBQ0wsV0FBVztJQUNkQSxZQUFZLFNBQVNBLFVBQVVNLElBQUksRUFBRUQsSUFBSTtRQUN2QyxPQUFPLElBQUlDLFFBQVFEO0lBQ3JCO0FBQ0Y7QUFDQSxNQUFNRSxlQUFlQyxRQUFRQyxNQUFNQyxTQUFTLENBQUNDLE9BQU87QUFDcEQsTUFBTUMsbUJBQW1CSixRQUFRQyxNQUFNQyxTQUFTLENBQUNHLFdBQVc7QUFDNUQsTUFBTUMsV0FBV04sUUFBUUMsTUFBTUMsU0FBUyxDQUFDSyxHQUFHO0FBQzVDLE1BQU1DLFlBQVlSLFFBQVFDLE1BQU1DLFNBQVMsQ0FBQ08sSUFBSTtBQUM5QyxNQUFNQyxjQUFjVixRQUFRQyxNQUFNQyxTQUFTLENBQUNTLE1BQU07QUFDbEQsTUFB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QUFFaFAsS0FBSztRQUNyRCwrQ0FBK0MsR0FDL0MsSUFBSSxDQUFDNkosUUFBUTtZQUNYSyxhQUFhLENBQUM7UUFDaEI7UUFDQSxNQUFNcUUsUUFBUW5QLGtCQUFrQmtSO1FBQ2hDLE1BQU05QixTQUFTcFAsa0JBQWtCNFA7UUFDakMsT0FBT1Ysa0JBQWtCQyxPQUFPQyxRQUFReE87SUFDMUM7SUFDQXNFLFVBQVVpTSxPQUFPLEdBQUcsU0FBVUMsVUFBVSxFQUFFQyxZQUFZO1FBQ3BELElBQUksT0FBT0EsaUJBQWlCLFlBQVk7WUFDdEM7UUFDRjtRQUNBelQsVUFBVXdKLEtBQUssQ0FBQ2dLLFdBQVcsRUFBRUM7SUFDL0I7SUFDQW5NLFVBQVVvTSxVQUFVLEdBQUcsU0FBVUYsVUFBVSxFQUFFQyxZQUFZO1FBQ3ZELElBQUlBLGlCQUFpQnBSLFdBQVc7WUFDOUIsTUFBTUssUUFBUTlDLGlCQUFpQjRKLEtBQUssQ0FBQ2dLLFdBQVcsRUFBRUM7WUFDbEQsT0FBTy9RLFVBQVUsQ0FBQyxJQUFJTCxZQUFZbkMsWUFBWXNKLEtBQUssQ0FBQ2dLLFdBQVcsRUFBRTlRLE9BQU8sRUFBRSxDQUFDLEVBQUU7UUFDL0U7UUFDQSxPQUFPNUMsU0FBUzBKLEtBQUssQ0FBQ2dLLFdBQVc7SUFDbkM7SUFDQWxNLFVBQVVxTSxXQUFXLEdBQUcsU0FBVUgsVUFBVTtRQUMxQ2hLLEtBQUssQ0FBQ2dLLFdBQVcsR0FBRyxFQUFFO0lBQ3hCO0lBQ0FsTSxVQUFVc00sY0FBYyxHQUFHO1FBQ3pCcEssUUFBUTdDO0lBQ1Y7SUFDQSxPQUFPVztBQUNUO0FBQ0EsSUFBSXVNLFNBQVN4TTtBQUVnQixDQUM3QixzQ0FBc0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9kZWVwcmVzZWFyY2gtY2hhdC8uL25vZGVfbW9kdWxlcy9kb21wdXJpZnkvZGlzdC9wdXJpZnkuZXMubWpzPzE0Y2EiXSwic291cmNlc0NvbnRlbnQiOlsiLyohIEBsaWNlbnNlIERPTVB1cmlmeSAzLjIuNCB8IChjKSBDdXJlNTMgYW5kIG90aGVyIGNvbnRyaWJ1dG9ycyB8IFJlbGVhc2VkIHVuZGVyIHRoZSBBcGFjaGUgbGljZW5zZSAyLjAgYW5kIE1vemlsbGEgUHVibGljIExpY2Vuc2UgMi4wIHwgZ2l0aHViLmNvbS9jdXJlNTMvRE9NUHVyaWZ5L2Jsb2IvMy4yLjQvTElDRU5TRSAqL1xuXG5jb25zdCB7XG4gIGVudHJpZXMsXG4gIHNldFByb3RvdHlwZU9mLFxuICBpc0Zyb3plbixcbiAgZ2V0UHJvdG90eXBlT2YsXG4gIGdldE93blByb3BlcnR5RGVzY3JpcHRvclxufSA9IE9iamVjdDtcbmxldCB7XG4gIGZyZWV6ZSxcbiAgc2VhbCxcbiAgY3JlYXRlXG59ID0gT2JqZWN0OyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGltcG9ydC9uby1tdXRhYmxlLWV4cG9ydHNcbmxldCB7XG4gIGFwcGx5LFxuICBjb25zdHJ1Y3Rcbn0gPSB0eXBlb2YgUmVmbGVjdCAhPT0gJ3VuZGVmaW5lZCcgJiYgUmVmbGVjdDtcbmlmICghZnJlZXplKSB7XG4gIGZyZWV6ZSA9IGZ1bmN0aW9uIGZyZWV6ZSh4KSB7XG4gICAgcmV0dXJuIHg7XG4gIH07XG59XG5pZiAoIXNlYWwpIHtcbiAgc2VhbCA9IGZ1bmN0aW9uIHNlYWwoeCkge1xuICAgIHJldHVybiB4O1xuICB9O1xufVxuaWYgKCFhcHBseSkge1xuICBhcHBseSA9IGZ1bmN0aW9uIGFwcGx5KGZ1biwgdGhpc1ZhbHVlLCBhcmdzKSB7XG4gICAgcmV0dXJuIGZ1bi5hcHBseSh0aGlzVmFsdWUsIGFyZ3MpO1xuICB9O1xufVxuaWYgKCFjb25zdHJ1Y3QpIHtcbiAgY29uc3RydWN0ID0gZnVuY3Rpb24gY29uc3RydWN0KEZ1bmMsIGFyZ3MpIHtcbiAgICByZXR1cm4gbmV3IEZ1bmMoLi4uYXJncyk7XG4gIH07XG59XG5jb25zdCBhcnJheUZvckVhY2ggPSB1bmFwcGx5KEFycmF5LnByb3RvdHlwZS5mb3JFYWNoKTtcbmNvbnN0IGFycmF5TGFzdEluZGV4T2YgPSB1bmFwcGx5KEFycmF5LnByb3RvdHlwZS5sYXN0SW5kZXhPZik7XG5jb25zdCBhcnJheVBvcCA9IHVuYXBwbHkoQXJyYXkucHJvdG90eXBlLnBvcCk7XG5jb25zdCBhcnJheVB1c2ggPSB1bmFwcGx5KEFycmF5LnByb3RvdHlwZS5wdXNoKTtcbmNvbnN0IGFycmF5U3BsaWNlID0gdW5hcHBseShBcnJheS5wcm90b3R5cGUuc3BsaWNlKTtcbmNvbnN0IHN0cmluZ1RvTG93ZXJDYXNlID0gdW5hcHBseShTdHJpbmcucHJvdG90eXBlLnRvTG93ZXJDYXNlKTtcbmNvbnN0IHN0cmluZ1RvU3RyaW5nID0gdW5hcHBseShTdHJpbmcucHJvdG90eXBlLnRvU3RyaW5nKTtcbmNvbnN0IHN0cmluZ01hdGNoID0gdW5hcHBseShTdHJpbmcucHJvdG90eXBlLm1hdGNoKTtcbmNvbnN0IHN0cmluZ1JlcGxhY2UgPSB1bmFwcGx5KFN0cmluZy5wcm90b3R5cGUucmVwbGFjZSk7XG5jb25zdCBzdHJpbmdJbmRleE9mID0gdW5hcHBseShTdHJpbmcucHJvdG90eXBlLmluZGV4T2YpO1xuY29uc3Qgc3RyaW5nVHJpbSA9IHVuYXBwbHkoU3RyaW5nLnByb3RvdHlwZS50cmltKTtcbmNvbnN0IG9iamVjdEhhc093blByb3BlcnR5ID0gdW5hcHBseShPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5KTtcbmNvbnN0IHJlZ0V4cFRlc3QgPSB1bmFwcGx5KFJlZ0V4cC5wcm90b3R5cGUudGVzdCk7XG5jb25zdCB0eXBlRXJyb3JDcmVhdGUgPSB1bmNvbnN0cnVjdChUeXBlRXJyb3IpO1xuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IGZ1bmN0aW9uIHRoYXQgY2FsbHMgdGhlIGdpdmVuIGZ1bmN0aW9uIHdpdGggYSBzcGVjaWZpZWQgdGhpc0FyZyBhbmQgYXJndW1lbnRzLlxuICpcbiAqIEBwYXJhbSBmdW5jIC0gVGhlIGZ1bmN0aW9uIHRvIGJlIHdyYXBwZWQgYW5kIGNhbGxlZC5cbiAqIEByZXR1cm5zIEEgbmV3IGZ1bmN0aW9uIHRoYXQgY2FsbHMgdGhlIGdpdmVuIGZ1bmN0aW9uIHdpdGggYSBzcGVjaWZpZWQgdGhpc0FyZyBhbmQgYXJndW1lbnRzLlxuICovXG5mdW5jdGlvbiB1bmFwcGx5KGZ1bmMpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICh0aGlzQXJnKSB7XG4gICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbiA+IDEgPyBfbGVuIC0gMSA6IDApLCBfa2V5ID0gMTsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgYXJnc1tfa2V5IC0gMV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgfVxuICAgIHJldHVybiBhcHBseShmdW5jLCB0aGlzQXJnLCBhcmdzKTtcbiAgfTtcbn1cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBmdW5jdGlvbiB0aGF0IGNvbnN0cnVjdHMgYW4gaW5zdGFuY2Ugb2YgdGhlIGdpdmVuIGNvbnN0cnVjdG9yIGZ1bmN0aW9uIHdpdGggdGhlIHByb3ZpZGVkIGFyZ3VtZW50cy5cbiAqXG4gKiBAcGFyYW0gZnVuYyAtIFRoZSBjb25zdHJ1Y3RvciBmdW5jdGlvbiB0byBiZSB3cmFwcGVkIGFuZCBjYWxsZWQuXG4gKiBAcmV0dXJucyBBIG5ldyBmdW5jdGlvbiB0aGF0IGNvbnN0cnVjdHMgYW4gaW5zdGFuY2Ugb2YgdGhlIGdpdmVuIGNvbnN0cnVjdG9yIGZ1bmN0aW9uIHdpdGggdGhlIHByb3ZpZGVkIGFyZ3VtZW50cy5cbiAqL1xuZnVuY3Rpb24gdW5jb25zdHJ1Y3QoZnVuYykge1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIGZvciAodmFyIF9sZW4yID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuMiksIF9rZXkyID0gMDsgX2tleTIgPCBfbGVuMjsgX2tleTIrKykge1xuICAgICAgYXJnc1tfa2V5Ml0gPSBhcmd1bWVudHNbX2tleTJdO1xuICAgIH1cbiAgICByZXR1cm4gY29uc3RydWN0KGZ1bmMsIGFyZ3MpO1xuICB9O1xufVxuLyoqXG4gKiBBZGQgcHJvcGVydGllcyB0byBhIGxvb2t1cCB0YWJsZVxuICpcbiAqIEBwYXJhbSBzZXQgLSBUaGUgc2V0IHRvIHdoaWNoIGVsZW1lbnRzIHdpbGwgYmUgYWRkZWQuXG4gKiBAcGFyYW0gYXJyYXkgLSBUaGUgYXJyYXkgY29udGFpbmluZyBlbGVtZW50cyB0byBiZSBhZGRlZCB0byB0aGUgc2V0LlxuICogQHBhcmFtIHRyYW5zZm9ybUNhc2VGdW5jIC0gQW4gb3B0aW9uYWwgZnVuY3Rpb24gdG8gdHJhbnNmb3JtIHRoZSBjYXNlIG9mIGVhY2ggZWxlbWVudCBiZWZvcmUgYWRkaW5nIHRvIHRoZSBzZXQuXG4gKiBAcmV0dXJucyBUaGUgbW9kaWZpZWQgc2V0IHdpdGggYWRkZWQgZWxlbWVudHMuXG4gKi9cbmZ1bmN0aW9uIGFkZFRvU2V0KHNldCwgYXJyYXkpIHtcbiAgbGV0IHRyYW5zZm9ybUNhc2VGdW5jID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiBzdHJpbmdUb0xvd2VyQ2FzZTtcbiAgaWYgKHNldFByb3RvdHlwZU9mKSB7XG4gICAgLy8gTWFrZSAnaW4nIGFuZCB0cnV0aHkgY2hlY2tzIGxpa2UgQm9vbGVhbihzZXQuY29uc3RydWN0b3IpXG4gICAgLy8gaW5kZXBlbmRlbnQgb2YgYW55IHByb3BlcnRpZXMgZGVmaW5lZCBvbiBPYmplY3QucHJvdG90eXBlLlxuICAgIC8vIFByZXZlbnQgcHJvdG90eXBlIHNldHRlcnMgZnJvbSBpbnRlcmNlcHRpbmcgc2V0IGFzIGEgdGhpcyB2YWx1ZS5cbiAgICBzZXRQcm90b3R5cGVPZihzZXQsIG51bGwpO1xuICB9XG4gIGxldCBsID0gYXJyYXkubGVuZ3RoO1xuICB3aGlsZSAobC0tKSB7XG4gICAgbGV0IGVsZW1lbnQgPSBhcnJheVtsXTtcbiAgICBpZiAodHlwZW9mIGVsZW1lbnQgPT09ICdzdHJpbmcnKSB7XG4gICAgICBjb25zdCBsY0VsZW1lbnQgPSB0cmFuc2Zvcm1DYXNlRnVuYyhlbGVtZW50KTtcbiAgICAgIGlmIChsY0VsZW1lbnQgIT09IGVsZW1lbnQpIHtcbiAgICAgICAgLy8gQ29uZmlnIHByZXNldHMgKGUuZy4gdGFncy5qcywgYXR0cnMuanMpIGFyZSBpbW11dGFibGUuXG4gICAgICAgIGlmICghaXNGcm96ZW4oYXJyYXkpKSB7XG4gICAgICAgICAgYXJyYXlbbF0gPSBsY0VsZW1lbnQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxlbWVudCA9IGxjRWxlbWVudDtcbiAgICAgIH1cbiAgICB9XG4gICAgc2V0W2VsZW1lbnRdID0gdHJ1ZTtcbiAgfVxuICByZXR1cm4gc2V0O1xufVxuLyoqXG4gKiBDbGVhbiB1cCBhbiBhcnJheSB0byBoYXJkZW4gYWdhaW5zdCBDU1BQXG4gKlxuICogQHBhcmFtIGFycmF5IC0gVGhlIGFycmF5IHRvIGJlIGNsZWFuZWQuXG4gKiBAcmV0dXJucyBUaGUgY2xlYW5lZCB2ZXJzaW9uIG9mIHRoZSBhcnJheVxuICovXG5mdW5jdGlvbiBjbGVhbkFycmF5KGFycmF5KSB7XG4gIGZvciAobGV0IGluZGV4ID0gMDsgaW5kZXggPCBhcnJheS5sZW5ndGg7IGluZGV4KyspIHtcbiAgICBjb25zdCBpc1Byb3BlcnR5RXhpc3QgPSBvYmplY3RIYXNPd25Qcm9wZXJ0eShhcnJheSwgaW5kZXgpO1xuICAgIGlmICghaXNQcm9wZXJ0eUV4aXN0KSB7XG4gICAgICBhcnJheVtpbmRleF0gPSBudWxsO1xuICAgIH1cbiAgfVxuICByZXR1cm4gYXJyYXk7XG59XG4vKipcbiAqIFNoYWxsb3cgY2xvbmUgYW4gb2JqZWN0XG4gKlxuICogQHBhcmFtIG9iamVjdCAtIFRoZSBvYmplY3QgdG8gYmUgY2xvbmVkLlxuICogQHJldHVybnMgQSBuZXcgb2JqZWN0IHRoYXQgY29waWVzIHRoZSBvcmlnaW5hbC5cbiAqL1xuZnVuY3Rpb24gY2xvbmUob2JqZWN0KSB7XG4gIGNvbnN0IG5ld09iamVjdCA9IGNyZWF0ZShudWxsKTtcbiAgZm9yIChjb25zdCBbcHJvcGVydHksIHZhbHVlXSBvZiBlbnRyaWVzKG9iamVjdCkpIHtcbiAgICBjb25zdCBpc1Byb3BlcnR5RXhpc3QgPSBvYmplY3RIYXNPd25Qcm9wZXJ0eShvYmplY3QsIHByb3BlcnR5KTtcbiAgICBpZiAoaXNQcm9wZXJ0eUV4aXN0KSB7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgbmV3T2JqZWN0W3Byb3BlcnR5XSA9IGNsZWFuQXJyYXkodmFsdWUpO1xuICAgICAgfSBlbHNlIGlmICh2YWx1ZSAmJiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmIHZhbHVlLmNvbnN0cnVjdG9yID09PSBPYmplY3QpIHtcbiAgICAgICAgbmV3T2JqZWN0W3Byb3BlcnR5XSA9IGNsb25lKHZhbHVlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5ld09iamVjdFtwcm9wZXJ0eV0gPSB2YWx1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIG5ld09iamVjdDtcbn1cbi8qKlxuICogVGhpcyBtZXRob2QgYXV0b21hdGljYWxseSBjaGVja3MgaWYgdGhlIHByb3AgaXMgZnVuY3Rpb24gb3IgZ2V0dGVyIGFuZCBiZWhhdmVzIGFjY29yZGluZ2x5LlxuICpcbiAqIEBwYXJhbSBvYmplY3QgLSBUaGUgb2JqZWN0IHRvIGxvb2sgdXAgdGhlIGdldHRlciBmdW5jdGlvbiBpbiBpdHMgcHJvdG90eXBlIGNoYWluLlxuICogQHBhcmFtIHByb3AgLSBUaGUgcHJvcGVydHkgbmFtZSBmb3Igd2hpY2ggdG8gZmluZCB0aGUgZ2V0dGVyIGZ1bmN0aW9uLlxuICogQHJldHVybnMgVGhlIGdldHRlciBmdW5jdGlvbiBmb3VuZCBpbiB0aGUgcHJvdG90eXBlIGNoYWluIG9yIGEgZmFsbGJhY2sgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGxvb2t1cEdldHRlcihvYmplY3QsIHByb3ApIHtcbiAgd2hpbGUgKG9iamVjdCAhPT0gbnVsbCkge1xuICAgIGNvbnN0IGRlc2MgPSBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBwcm9wKTtcbiAgICBpZiAoZGVzYykge1xuICAgICAgaWYgKGRlc2MuZ2V0KSB7XG4gICAgICAgIHJldHVybiB1bmFwcGx5KGRlc2MuZ2V0KTtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YgZGVzYy52YWx1ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZXR1cm4gdW5hcHBseShkZXNjLnZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgb2JqZWN0ID0gZ2V0UHJvdG90eXBlT2Yob2JqZWN0KTtcbiAgfVxuICBmdW5jdGlvbiBmYWxsYmFja1ZhbHVlKCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHJldHVybiBmYWxsYmFja1ZhbHVlO1xufVxuXG5jb25zdCBodG1sJDEgPSBmcmVlemUoWydhJywgJ2FiYnInLCAnYWNyb255bScsICdhZGRyZXNzJywgJ2FyZWEnLCAnYXJ0aWNsZScsICdhc2lkZScsICdhdWRpbycsICdiJywgJ2JkaScsICdiZG8nLCAnYmlnJywgJ2JsaW5rJywgJ2Jsb2NrcXVvdGUnLCAnYm9keScsICdicicsICdidXR0b24nLCAnY2FudmFzJywgJ2NhcHRpb24nLCAnY2VudGVyJywgJ2NpdGUnLCAnY29kZScsICdjb2wnLCAnY29sZ3JvdXAnLCAnY29udGVudCcsICdkYXRhJywgJ2RhdGFsaXN0JywgJ2RkJywgJ2RlY29yYXRvcicsICdkZWwnLCAnZGV0YWlscycsICdkZm4nLCAnZGlhbG9nJywgJ2RpcicsICdkaXYnLCAnZGwnLCAnZHQnLCAnZWxlbWVudCcsICdlbScsICdmaWVsZHNldCcsICdmaWdjYXB0aW9uJywgJ2ZpZ3VyZScsICdmb250JywgJ2Zvb3RlcicsICdmb3JtJywgJ2gxJywgJ2gyJywgJ2gzJywgJ2g0JywgJ2g1JywgJ2g2JywgJ2hlYWQnLCAnaGVhZGVyJywgJ2hncm91cCcsICdocicsICdodG1sJywgJ2knLCAnaW1nJywgJ2lucHV0JywgJ2lucycsICdrYmQnLCAnbGFiZWwnLCAnbGVnZW5kJywgJ2xpJywgJ21haW4nLCAnbWFwJywgJ21hcmsnLCAnbWFycXVlZScsICdtZW51JywgJ21lbnVpdGVtJywgJ21ldGVyJywgJ25hdicsICdub2JyJywgJ29sJywgJ29wdGdyb3VwJywgJ29wdGlvbicsICdvdXRwdXQnLCAncCcsICdwaWN0dXJlJywgJ3ByZScsICdwcm9ncmVzcycsICdxJywgJ3JwJywgJ3J0JywgJ3J1YnknLCAncycsICdzYW1wJywgJ3NlY3Rpb24nLCAnc2VsZWN0JywgJ3NoYWRvdycsICdzbWFsbCcsICdzb3VyY2UnLCAnc3BhY2VyJywgJ3NwYW4nLCAnc3RyaWtlJywgJ3N0cm9uZycsICdzdHlsZScsICdzdWInLCAnc3VtbWFyeScsICdzdXAnLCAndGFibGUnLCAndGJvZHknLCAndGQnLCAndGVtcGxhdGUnLCAndGV4dGFyZWEnLCAndGZvb3QnLCAndGgnLCAndGhlYWQnLCAndGltZScsICd0cicsICd0cmFjaycsICd0dCcsICd1JywgJ3VsJywgJ3ZhcicsICd2aWRlbycsICd3YnInXSk7XG5jb25zdCBzdmckMSA9IGZyZWV6ZShbJ3N2ZycsICdhJywgJ2FsdGdseXBoJywgJ2FsdGdseXBoZGVmJywgJ2FsdGdseXBoaXRlbScsICdhbmltYXRlY29sb3InLCAnYW5pbWF0ZW1vdGlvbicsICdhbmltYXRldHJhbnNmb3JtJywgJ2NpcmNsZScsICdjbGlwcGF0aCcsICdkZWZzJywgJ2Rlc2MnLCAnZWxsaXBzZScsICdmaWx0ZXInLCAnZm9udCcsICdnJywgJ2dseXBoJywgJ2dseXBocmVmJywgJ2hrZXJuJywgJ2ltYWdlJywgJ2xpbmUnLCAnbGluZWFyZ3JhZGllbnQnLCAnbWFya2VyJywgJ21hc2snLCAnbWV0YWRhdGEnLCAnbXBhdGgnLCAncGF0aCcsICdwYXR0ZXJuJywgJ3BvbHlnb24nLCAncG9seWxpbmUnLCAncmFkaWFsZ3JhZGllbnQnLCAncmVjdCcsICdzdG9wJywgJ3N0eWxlJywgJ3N3aXRjaCcsICdzeW1ib2wnLCAndGV4dCcsICd0ZXh0cGF0aCcsICd0aXRsZScsICd0cmVmJywgJ3RzcGFuJywgJ3ZpZXcnLCAndmtlcm4nXSk7XG5jb25zdCBzdmdGaWx0ZXJzID0gZnJlZXplKFsnZmVCbGVuZCcsICdmZUNvbG9yTWF0cml4JywgJ2ZlQ29tcG9uZW50VHJhbnNmZXInLCAnZmVDb21wb3NpdGUnLCAnZmVDb252b2x2ZU1hdHJpeCcsICdmZURpZmZ1c2VMaWdodGluZycsICdmZURpc3BsYWNlbWVudE1hcCcsICdmZURpc3RhbnRMaWdodCcsICdmZURyb3BTaGFkb3cnLCAnZmVGbG9vZCcsICdmZUZ1bmNBJywgJ2ZlRnVuY0InLCAnZmVGdW5jRycsICdmZUZ1bmNSJywgJ2ZlR2F1c3NpYW5CbHVyJywgJ2ZlSW1hZ2UnLCAnZmVNZXJnZScsICdmZU1lcmdlTm9kZScsICdmZU1vcnBob2xvZ3knLCAnZmVPZmZzZXQnLCAnZmVQb2ludExpZ2h0JywgJ2ZlU3BlY3VsYXJMaWdodGluZycsICdmZVNwb3RMaWdodCcsICdmZVRpbGUnLCAnZmVUdXJidWxlbmNlJ10pO1xuLy8gTGlzdCBvZiBTVkcgZWxlbWVudHMgdGhhdCBhcmUgZGlzYWxsb3dlZCBieSBkZWZhdWx0LlxuLy8gV2Ugc3RpbGwgbmVlZCB0byBrbm93IHRoZW0gc28gdGhhdCB3ZSBjYW4gZG8gbmFtZXNwYWNlXG4vLyBjaGVja3MgcHJvcGVybHkgaW4gY2FzZSBvbmUgd2FudHMgdG8gYWRkIHRoZW0gdG9cbi8vIGFsbG93LWxpc3QuXG5jb25zdCBzdmdEaXNhbGxvd2VkID0gZnJlZXplKFsnYW5pbWF0ZScsICdjb2xvci1wcm9maWxlJywgJ2N1cnNvcicsICdkaXNjYXJkJywgJ2ZvbnQtZmFjZScsICdmb250LWZhY2UtZm9ybWF0JywgJ2ZvbnQtZmFjZS1uYW1lJywgJ2ZvbnQtZmFjZS1zcmMnLCAnZm9udC1mYWNlLXVyaScsICdmb3JlaWdub2JqZWN0JywgJ2hhdGNoJywgJ2hhdGNocGF0aCcsICdtZXNoJywgJ21lc2hncmFkaWVudCcsICdtZXNocGF0Y2gnLCAnbWVzaHJvdycsICdtaXNzaW5nLWdseXBoJywgJ3NjcmlwdCcsICdzZXQnLCAnc29saWRjb2xvcicsICd1bmtub3duJywgJ3VzZSddKTtcbmNvbnN0IG1hdGhNbCQxID0gZnJlZXplKFsnbWF0aCcsICdtZW5jbG9zZScsICdtZXJyb3InLCAnbWZlbmNlZCcsICdtZnJhYycsICdtZ2x5cGgnLCAnbWknLCAnbWxhYmVsZWR0cicsICdtbXVsdGlzY3JpcHRzJywgJ21uJywgJ21vJywgJ21vdmVyJywgJ21wYWRkZWQnLCAnbXBoYW50b20nLCAnbXJvb3QnLCAnbXJvdycsICdtcycsICdtc3BhY2UnLCAnbXNxcnQnLCAnbXN0eWxlJywgJ21zdWInLCAnbXN1cCcsICdtc3Vic3VwJywgJ210YWJsZScsICdtdGQnLCAnbXRleHQnLCAnbXRyJywgJ211bmRlcicsICdtdW5kZXJvdmVyJywgJ21wcmVzY3JpcHRzJ10pO1xuLy8gU2ltaWxhcmx5IHRvIFNWRywgd2Ugd2FudCB0byBrbm93IGFsbCBNYXRoTUwgZWxlbWVudHMsXG4vLyBldmVuIHRob3NlIHRoYXQgd2UgZGlzYWxsb3cgYnkgZGVmYXVsdC5cbmNvbnN0IG1hdGhNbERpc2FsbG93ZWQgPSBmcmVlemUoWydtYWN0aW9uJywgJ21hbGlnbmdyb3VwJywgJ21hbGlnbm1hcmsnLCAnbWxvbmdkaXYnLCAnbXNjYXJyaWVzJywgJ21zY2FycnknLCAnbXNncm91cCcsICdtc3RhY2snLCAnbXNsaW5lJywgJ21zcm93JywgJ3NlbWFudGljcycsICdhbm5vdGF0aW9uJywgJ2Fubm90YXRpb24teG1sJywgJ21wcmVzY3JpcHRzJywgJ25vbmUnXSk7XG5jb25zdCB0ZXh0ID0gZnJlZXplKFsnI3RleHQnXSk7XG5cbmNvbnN0IGh0bWwgPSBmcmVlemUoWydhY2NlcHQnLCAnYWN0aW9uJywgJ2FsaWduJywgJ2FsdCcsICdhdXRvY2FwaXRhbGl6ZScsICdhdXRvY29tcGxldGUnLCAnYXV0b3BpY3R1cmVpbnBpY3R1cmUnLCAnYXV0b3BsYXknLCAnYmFja2dyb3VuZCcsICdiZ2NvbG9yJywgJ2JvcmRlcicsICdjYXB0dXJlJywgJ2NlbGxwYWRkaW5nJywgJ2NlbGxzcGFjaW5nJywgJ2NoZWNrZWQnLCAnY2l0ZScsICdjbGFzcycsICdjbGVhcicsICdjb2xvcicsICdjb2xzJywgJ2NvbHNwYW4nLCAnY29udHJvbHMnLCAnY29udHJvbHNsaXN0JywgJ2Nvb3JkcycsICdjcm9zc29yaWdpbicsICdkYXRldGltZScsICdkZWNvZGluZycsICdkZWZhdWx0JywgJ2RpcicsICdkaXNhYmxlZCcsICdkaXNhYmxlcGljdHVyZWlucGljdHVyZScsICdkaXNhYmxlcmVtb3RlcGxheWJhY2snLCAnZG93bmxvYWQnLCAnZHJhZ2dhYmxlJywgJ2VuY3R5cGUnLCAnZW50ZXJrZXloaW50JywgJ2ZhY2UnLCAnZm9yJywgJ2hlYWRlcnMnLCAnaGVpZ2h0JywgJ2hpZGRlbicsICdoaWdoJywgJ2hyZWYnLCAnaHJlZmxhbmcnLCAnaWQnLCAnaW5wdXRtb2RlJywgJ2ludGVncml0eScsICdpc21hcCcsICdraW5kJywgJ2xhYmVsJywgJ2xhbmcnLCAnbGlzdCcsICdsb2FkaW5nJywgJ2xvb3AnLCAnbG93JywgJ21heCcsICdtYXhsZW5ndGgnLCAnbWVkaWEnLCAnbWV0aG9kJywgJ21pbicsICdtaW5sZW5ndGgnLCAnbXVsdGlwbGUnLCAnbXV0ZWQnLCAnbmFtZScsICdub25jZScsICdub3NoYWRlJywgJ25vdmFsaWRhdGUnLCAnbm93cmFwJywgJ29wZW4nLCAnb3B0aW11bScsICdwYXR0ZXJuJywgJ3BsYWNlaG9sZGVyJywgJ3BsYXlzaW5saW5lJywgJ3BvcG92ZXInLCAncG9wb3ZlcnRhcmdldCcsICdwb3BvdmVydGFyZ2V0YWN0aW9uJywgJ3Bvc3RlcicsICdwcmVsb2FkJywgJ3B1YmRhdGUnLCAncmFkaW9ncm91cCcsICdyZWFkb25seScsICdyZWwnLCAncmVxdWlyZWQnLCAncmV2JywgJ3JldmVyc2VkJywgJ3JvbGUnLCAncm93cycsICdyb3dzcGFuJywgJ3NwZWxsY2hlY2snLCAnc2NvcGUnLCAnc2VsZWN0ZWQnLCAnc2hhcGUnLCAnc2l6ZScsICdzaXplcycsICdzcGFuJywgJ3NyY2xhbmcnLCAnc3RhcnQnLCAnc3JjJywgJ3NyY3NldCcsICdzdGVwJywgJ3N0eWxlJywgJ3N1bW1hcnknLCAndGFiaW5kZXgnLCAndGl0bGUnLCAndHJhbnNsYXRlJywgJ3R5cGUnLCAndXNlbWFwJywgJ3ZhbGlnbicsICd2YWx1ZScsICd3aWR0aCcsICd3cmFwJywgJ3htbG5zJywgJ3Nsb3QnXSk7XG5jb25zdCBzdmcgPSBmcmVlemUoWydhY2NlbnQtaGVpZ2h0JywgJ2FjY3VtdWxhdGUnLCAnYWRkaXRpdmUnLCAnYWxpZ25tZW50LWJhc2VsaW5lJywgJ2FtcGxpdHVkZScsICdhc2NlbnQnLCAnYXR0cmlidXRlbmFtZScsICdhdHRyaWJ1dGV0eXBlJywgJ2F6aW11dGgnLCAnYmFzZWZyZXF1ZW5jeScsICdiYXNlbGluZS1zaGlmdCcsICdiZWdpbicsICdiaWFzJywgJ2J5JywgJ2NsYXNzJywgJ2NsaXAnLCAnY2xpcHBhdGh1bml0cycsICdjbGlwLXBhdGgnLCAnY2xpcC1ydWxlJywgJ2NvbG9yJywgJ2NvbG9yLWludGVycG9sYXRpb24nLCAnY29sb3ItaW50ZXJwb2xhdGlvbi1maWx0ZXJzJywgJ2NvbG9yLXByb2ZpbGUnLCAnY29sb3ItcmVuZGVyaW5nJywgJ2N4JywgJ2N5JywgJ2QnLCAnZHgnLCAnZHknLCAnZGlmZnVzZWNvbnN0YW50JywgJ2RpcmVjdGlvbicsICdkaXNwbGF5JywgJ2Rpdmlzb3InLCAnZHVyJywgJ2VkZ2Vtb2RlJywgJ2VsZXZhdGlvbicsICdlbmQnLCAnZXhwb25lbnQnLCAnZmlsbCcsICdmaWxsLW9wYWNpdHknLCAnZmlsbC1ydWxlJywgJ2ZpbHRlcicsICdmaWx0ZXJ1bml0cycsICdmbG9vZC1jb2xvcicsICdmbG9vZC1vcGFjaXR5JywgJ2ZvbnQtZmFtaWx5JywgJ2ZvbnQtc2l6ZScsICdmb250LXNpemUtYWRqdXN0JywgJ2ZvbnQtc3RyZXRjaCcsICdmb250LXN0eWxlJywgJ2ZvbnQtdmFyaWFudCcsICdmb250LXdlaWdodCcsICdmeCcsICdmeScsICdnMScsICdnMicsICdnbHlwaC1uYW1lJywgJ2dseXBocmVmJywgJ2dyYWRpZW50dW5pdHMnLCAnZ3JhZGllbnR0cmFuc2Zvcm0nLCAnaGVpZ2h0JywgJ2hyZWYnLCAnaWQnLCAnaW1hZ2UtcmVuZGVyaW5nJywgJ2luJywgJ2luMicsICdpbnRlcmNlcHQnLCAnaycsICdrMScsICdrMicsICdrMycsICdrNCcsICdrZXJuaW5nJywgJ2tleXBvaW50cycsICdrZXlzcGxpbmVzJywgJ2tleXRpbWVzJywgJ2xhbmcnLCAnbGVuZ3RoYWRqdXN0JywgJ2xldHRlci1zcGFjaW5nJywgJ2tlcm5lbG1hdHJpeCcsICdrZXJuZWx1bml0bGVuZ3RoJywgJ2xpZ2h0aW5nLWNvbG9yJywgJ2xvY2FsJywgJ21hcmtlci1lbmQnLCAnbWFya2VyLW1pZCcsICdtYXJrZXItc3RhcnQnLCAnbWFya2VyaGVpZ2h0JywgJ21hcmtlcnVuaXRzJywgJ21hcmtlcndpZHRoJywgJ21hc2tjb250ZW50dW5pdHMnLCAnbWFza3VuaXRzJywgJ21heCcsICdtYXNrJywgJ21lZGlhJywgJ21ldGhvZCcsICdtb2RlJywgJ21pbicsICduYW1lJywgJ251bW9jdGF2ZXMnLCAnb2Zmc2V0JywgJ29wZXJhdG9yJywgJ29wYWNpdHknLCAnb3JkZXInLCAnb3JpZW50JywgJ29yaWVudGF0aW9uJywgJ29yaWdpbicsICdvdmVyZmxvdycsICdwYWludC1vcmRlcicsICdwYXRoJywgJ3BhdGhsZW5ndGgnLCAncGF0dGVybmNvbnRlbnR1bml0cycsICdwYXR0ZXJudHJhbnNmb3JtJywgJ3BhdHRlcm51bml0cycsICdwb2ludHMnLCAncHJlc2VydmVhbHBoYScsICdwcmVzZXJ2ZWFzcGVjdHJhdGlvJywgJ3ByaW1pdGl2ZXVuaXRzJywgJ3InLCAncngnLCAncnknLCAncmFkaXVzJywgJ3JlZngnLCAncmVmeScsICdyZXBlYXRjb3VudCcsICdyZXBlYXRkdXInLCAncmVzdGFydCcsICdyZXN1bHQnLCAncm90YXRlJywgJ3NjYWxlJywgJ3NlZWQnLCAnc2hhcGUtcmVuZGVyaW5nJywgJ3Nsb3BlJywgJ3NwZWN1bGFyY29uc3RhbnQnLCAnc3BlY3VsYXJleHBvbmVudCcsICdzcHJlYWRtZXRob2QnLCAnc3RhcnRvZmZzZXQnLCAnc3RkZGV2aWF0aW9uJywgJ3N0aXRjaHRpbGVzJywgJ3N0b3AtY29sb3InLCAnc3RvcC1vcGFjaXR5JywgJ3N0cm9rZS1kYXNoYXJyYXknLCAnc3Ryb2tlLWRhc2hvZmZzZXQnLCAnc3Ryb2tlLWxpbmVjYXAnLCAnc3Ryb2tlLWxpbmVqb2luJywgJ3N0cm9rZS1taXRlcmxpbWl0JywgJ3N0cm9rZS1vcGFjaXR5JywgJ3N0cm9rZScsICdzdHJva2Utd2lkdGgnLCAnc3R5bGUnLCAnc3VyZmFjZXNjYWxlJywgJ3N5c3RlbWxhbmd1YWdlJywgJ3RhYmluZGV4JywgJ3RhYmxldmFsdWVzJywgJ3RhcmdldHgnLCAndGFyZ2V0eScsICd0cmFuc2Zvcm0nLCAndHJhbnNmb3JtLW9yaWdpbicsICd0ZXh0LWFuY2hvcicsICd0ZXh0LWRlY29yYXRpb24nLCAndGV4dC1yZW5kZXJpbmcnLCAndGV4dGxlbmd0aCcsICd0eXBlJywgJ3UxJywgJ3UyJywgJ3VuaWNvZGUnLCAndmFsdWVzJywgJ3ZpZXdib3gnLCAndmlzaWJpbGl0eScsICd2ZXJzaW9uJywgJ3ZlcnQtYWR2LXknLCAndmVydC1vcmlnaW4teCcsICd2ZXJ0LW9yaWdpbi15JywgJ3dpZHRoJywgJ3dvcmQtc3BhY2luZycsICd3cmFwJywgJ3dyaXRpbmctbW9kZScsICd4Y2hhbm5lbHNlbGVjdG9yJywgJ3ljaGFubmVsc2VsZWN0b3InLCAneCcsICd4MScsICd4MicsICd4bWxucycsICd5JywgJ3kxJywgJ3kyJywgJ3onLCAnem9vbWFuZHBhbiddKTtcbmNvbnN0IG1hdGhNbCA9IGZyZWV6ZShbJ2FjY2VudCcsICdhY2NlbnR1bmRlcicsICdhbGlnbicsICdiZXZlbGxlZCcsICdjbG9zZScsICdjb2x1bW5zYWxpZ24nLCAnY29sdW1ubGluZXMnLCAnY29sdW1uc3BhbicsICdkZW5vbWFsaWduJywgJ2RlcHRoJywgJ2RpcicsICdkaXNwbGF5JywgJ2Rpc3BsYXlzdHlsZScsICdlbmNvZGluZycsICdmZW5jZScsICdmcmFtZScsICdoZWlnaHQnLCAnaHJlZicsICdpZCcsICdsYXJnZW9wJywgJ2xlbmd0aCcsICdsaW5ldGhpY2tuZXNzJywgJ2xzcGFjZScsICdscXVvdGUnLCAnbWF0aGJhY2tncm91bmQnLCAnbWF0aGNvbG9yJywgJ21hdGhzaXplJywgJ21hdGh2YXJpYW50JywgJ21heHNpemUnLCAnbWluc2l6ZScsICdtb3ZhYmxlbGltaXRzJywgJ25vdGF0aW9uJywgJ251bWFsaWduJywgJ29wZW4nLCAncm93YWxpZ24nLCAncm93bGluZXMnLCAncm93c3BhY2luZycsICdyb3dzcGFuJywgJ3JzcGFjZScsICdycXVvdGUnLCAnc2NyaXB0bGV2ZWwnLCAnc2NyaXB0bWluc2l6ZScsICdzY3JpcHRzaXplbXVsdGlwbGllcicsICdzZWxlY3Rpb24nLCAnc2VwYXJhdG9yJywgJ3NlcGFyYXRvcnMnLCAnc3RyZXRjaHknLCAnc3Vic2NyaXB0c2hpZnQnLCAnc3Vwc2NyaXB0c2hpZnQnLCAnc3ltbWV0cmljJywgJ3ZvZmZzZXQnLCAnd2lkdGgnLCAneG1sbnMnXSk7XG5jb25zdCB4bWwgPSBmcmVlemUoWyd4bGluazpocmVmJywgJ3htbDppZCcsICd4bGluazp0aXRsZScsICd4bWw6c3BhY2UnLCAneG1sbnM6eGxpbmsnXSk7XG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSB1bmljb3JuL2JldHRlci1yZWdleFxuY29uc3QgTVVTVEFDSEVfRVhQUiA9IHNlYWwoL1xce1xce1tcXHdcXFddKnxbXFx3XFxXXSpcXH1cXH0vZ20pOyAvLyBTcGVjaWZ5IHRlbXBsYXRlIGRldGVjdGlvbiByZWdleCBmb3IgU0FGRV9GT1JfVEVNUExBVEVTIG1vZGVcbmNvbnN0IEVSQl9FWFBSID0gc2VhbCgvPCVbXFx3XFxXXSp8W1xcd1xcV10qJT4vZ20pO1xuY29uc3QgVE1QTElUX0VYUFIgPSBzZWFsKC9cXCRcXHtbXFx3XFxXXSovZ20pOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIHVuaWNvcm4vYmV0dGVyLXJlZ2V4XG5jb25zdCBEQVRBX0FUVFIgPSBzZWFsKC9eZGF0YS1bXFwtXFx3LlxcdTAwQjctXFx1RkZGRl0rJC8pOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVzZWxlc3MtZXNjYXBlXG5jb25zdCBBUklBX0FUVFIgPSBzZWFsKC9eYXJpYS1bXFwtXFx3XSskLyk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdXNlbGVzcy1lc2NhcGVcbmNvbnN0IElTX0FMTE9XRURfVVJJID0gc2VhbCgvXig/Oig/Oig/OmZ8aHQpdHBzP3xtYWlsdG98dGVsfGNhbGx0b3xzbXN8Y2lkfHhtcHApOnxbXmEtel18W2EteisuXFwtXSsoPzpbXmEteisuXFwtOl18JCkpL2kgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11c2VsZXNzLWVzY2FwZVxuKTtcbmNvbnN0IElTX1NDUklQVF9PUl9EQVRBID0gc2VhbCgvXig/OlxcdytzY3JpcHR8ZGF0YSk6L2kpO1xuY29uc3QgQVRUUl9XSElURVNQQUNFID0gc2VhbCgvW1xcdTAwMDAtXFx1MDAyMFxcdTAwQTBcXHUxNjgwXFx1MTgwRVxcdTIwMDAtXFx1MjAyOVxcdTIwNUZcXHUzMDAwXS9nIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tY29udHJvbC1yZWdleFxuKTtcbmNvbnN0IERPQ1RZUEVfTkFNRSA9IHNlYWwoL15odG1sJC9pKTtcbmNvbnN0IENVU1RPTV9FTEVNRU5UID0gc2VhbCgvXlthLXpdWy5cXHddKigtWy5cXHddKykrJC9pKTtcblxudmFyIEVYUFJFU1NJT05TID0gLyojX19QVVJFX18qL09iamVjdC5mcmVlemUoe1xuICBfX3Byb3RvX186IG51bGwsXG4gIEFSSUFfQVRUUjogQVJJQV9BVFRSLFxuICBBVFRSX1dISVRFU1BBQ0U6IEFUVFJfV0hJVEVTUEFDRSxcbiAgQ1VTVE9NX0VMRU1FTlQ6IENVU1RPTV9FTEVNRU5ULFxuICBEQVRBX0FUVFI6IERBVEFfQVRUUixcbiAgRE9DVFlQRV9OQU1FOiBET0NUWVBFX05BTUUsXG4gIEVSQl9FWFBSOiBFUkJfRVhQUixcbiAgSVNfQUxMT1dFRF9VUkk6IElTX0FMTE9XRURfVVJJLFxuICBJU19TQ1JJUFRfT1JfREFUQTogSVNfU0NSSVBUX09SX0RBVEEsXG4gIE1VU1RBQ0hFX0VYUFI6IE1VU1RBQ0hFX0VYUFIsXG4gIFRNUExJVF9FWFBSOiBUTVBMSVRfRVhQUlxufSk7XG5cbi8qIGVzbGludC1kaXNhYmxlIEB0eXBlc2NyaXB0LWVzbGludC9pbmRlbnQgKi9cbi8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9Ob2RlL25vZGVUeXBlXG5jb25zdCBOT0RFX1RZUEUgPSB7XG4gIGVsZW1lbnQ6IDEsXG4gIGF0dHJpYnV0ZTogMixcbiAgdGV4dDogMyxcbiAgY2RhdGFTZWN0aW9uOiA0LFxuICBlbnRpdHlSZWZlcmVuY2U6IDUsXG4gIC8vIERlcHJlY2F0ZWRcbiAgZW50aXR5Tm9kZTogNixcbiAgLy8gRGVwcmVjYXRlZFxuICBwcm9ncmVzc2luZ0luc3RydWN0aW9uOiA3LFxuICBjb21tZW50OiA4LFxuICBkb2N1bWVudDogOSxcbiAgZG9jdW1lbnRUeXBlOiAxMCxcbiAgZG9jdW1lbnRGcmFnbWVudDogMTEsXG4gIG5vdGF0aW9uOiAxMiAvLyBEZXByZWNhdGVkXG59O1xuY29uc3QgZ2V0R2xvYmFsID0gZnVuY3Rpb24gZ2V0R2xvYmFsKCkge1xuICByZXR1cm4gdHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcgPyBudWxsIDogd2luZG93O1xufTtcbi8qKlxuICogQ3JlYXRlcyBhIG5vLW9wIHBvbGljeSBmb3IgaW50ZXJuYWwgdXNlIG9ubHkuXG4gKiBEb24ndCBleHBvcnQgdGhpcyBmdW5jdGlvbiBvdXRzaWRlIHRoaXMgbW9kdWxlIVxuICogQHBhcmFtIHRydXN0ZWRUeXBlcyBUaGUgcG9saWN5IGZhY3RvcnkuXG4gKiBAcGFyYW0gcHVyaWZ5SG9zdEVsZW1lbnQgVGhlIFNjcmlwdCBlbGVtZW50IHVzZWQgdG8gbG9hZCBET01QdXJpZnkgKHRvIGRldGVybWluZSBwb2xpY3kgbmFtZSBzdWZmaXgpLlxuICogQHJldHVybiBUaGUgcG9saWN5IGNyZWF0ZWQgKG9yIG51bGwsIGlmIFRydXN0ZWQgVHlwZXNcbiAqIGFyZSBub3Qgc3VwcG9ydGVkIG9yIGNyZWF0aW5nIHRoZSBwb2xpY3kgZmFpbGVkKS5cbiAqL1xuY29uc3QgX2NyZWF0ZVRydXN0ZWRUeXBlc1BvbGljeSA9IGZ1bmN0aW9uIF9jcmVhdGVUcnVzdGVkVHlwZXNQb2xpY3kodHJ1c3RlZFR5cGVzLCBwdXJpZnlIb3N0RWxlbWVudCkge1xuICBpZiAodHlwZW9mIHRydXN0ZWRUeXBlcyAhPT0gJ29iamVjdCcgfHwgdHlwZW9mIHRydXN0ZWRUeXBlcy5jcmVhdGVQb2xpY3kgIT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICAvLyBBbGxvdyB0aGUgY2FsbGVycyB0byBjb250cm9sIHRoZSB1bmlxdWUgcG9saWN5IG5hbWVcbiAgLy8gYnkgYWRkaW5nIGEgZGF0YS10dC1wb2xpY3ktc3VmZml4IHRvIHRoZSBzY3JpcHQgZWxlbWVudCB3aXRoIHRoZSBET01QdXJpZnkuXG4gIC8vIFBvbGljeSBjcmVhdGlvbiB3aXRoIGR1cGxpY2F0ZSBuYW1lcyB0aHJvd3MgaW4gVHJ1c3RlZCBUeXBlcy5cbiAgbGV0IHN1ZmZpeCA9IG51bGw7XG4gIGNvbnN0IEFUVFJfTkFNRSA9ICdkYXRhLXR0LXBvbGljeS1zdWZmaXgnO1xuICBpZiAocHVyaWZ5SG9zdEVsZW1lbnQgJiYgcHVyaWZ5SG9zdEVsZW1lbnQuaGFzQXR0cmlidXRlKEFUVFJfTkFNRSkpIHtcbiAgICBzdWZmaXggPSBwdXJpZnlIb3N0RWxlbWVudC5nZXRBdHRyaWJ1dGUoQVRUUl9OQU1FKTtcbiAgfVxuICBjb25zdCBwb2xpY3lOYW1lID0gJ2RvbXB1cmlmeScgKyAoc3VmZml4ID8gJyMnICsgc3VmZml4IDogJycpO1xuICB0cnkge1xuICAgIHJldHVybiB0cnVzdGVkVHlwZXMuY3JlYXRlUG9saWN5KHBvbGljeU5hbWUsIHtcbiAgICAgIGNyZWF0ZUhUTUwoaHRtbCkge1xuICAgICAgICByZXR1cm4gaHRtbDtcbiAgICAgIH0sXG4gICAgICBjcmVhdGVTY3JpcHRVUkwoc2NyaXB0VXJsKSB7XG4gICAgICAgIHJldHVybiBzY3JpcHRVcmw7XG4gICAgICB9XG4gICAgfSk7XG4gIH0gY2F0Y2ggKF8pIHtcbiAgICAvLyBQb2xpY3kgY3JlYXRpb24gZmFpbGVkIChtb3N0IGxpa2VseSBhbm90aGVyIERPTVB1cmlmeSBzY3JpcHQgaGFzXG4gICAgLy8gYWxyZWFkeSBydW4pLiBTa2lwIGNyZWF0aW5nIHRoZSBwb2xpY3ksIGFzIHRoaXMgd2lsbCBvbmx5IGNhdXNlIGVycm9yc1xuICAgIC8vIGlmIFRUIGFyZSBlbmZvcmNlZC5cbiAgICBjb25zb2xlLndhcm4oJ1RydXN0ZWRUeXBlcyBwb2xpY3kgJyArIHBvbGljeU5hbWUgKyAnIGNvdWxkIG5vdCBiZSBjcmVhdGVkLicpO1xuICAgIHJldHVybiBudWxsO1xuICB9XG59O1xuY29uc3QgX2NyZWF0ZUhvb2tzTWFwID0gZnVuY3Rpb24gX2NyZWF0ZUhvb2tzTWFwKCkge1xuICByZXR1cm4ge1xuICAgIGFmdGVyU2FuaXRpemVBdHRyaWJ1dGVzOiBbXSxcbiAgICBhZnRlclNhbml0aXplRWxlbWVudHM6IFtdLFxuICAgIGFmdGVyU2FuaXRpemVTaGFkb3dET006IFtdLFxuICAgIGJlZm9yZVNhbml0aXplQXR0cmlidXRlczogW10sXG4gICAgYmVmb3JlU2FuaXRpemVFbGVtZW50czogW10sXG4gICAgYmVmb3JlU2FuaXRpemVTaGFkb3dET006IFtdLFxuICAgIHVwb25TYW5pdGl6ZUF0dHJpYnV0ZTogW10sXG4gICAgdXBvblNhbml0aXplRWxlbWVudDogW10sXG4gICAgdXBvblNhbml0aXplU2hhZG93Tm9kZTogW11cbiAgfTtcbn07XG5mdW5jdGlvbiBjcmVhdGVET01QdXJpZnkoKSB7XG4gIGxldCB3aW5kb3cgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IGdldEdsb2JhbCgpO1xuICBjb25zdCBET01QdXJpZnkgPSByb290ID0+IGNyZWF0ZURPTVB1cmlmeShyb290KTtcbiAgRE9NUHVyaWZ5LnZlcnNpb24gPSAnMy4yLjQnO1xuICBET01QdXJpZnkucmVtb3ZlZCA9IFtdO1xuICBpZiAoIXdpbmRvdyB8fCAhd2luZG93LmRvY3VtZW50IHx8IHdpbmRvdy5kb2N1bWVudC5ub2RlVHlwZSAhPT0gTk9ERV9UWVBFLmRvY3VtZW50IHx8ICF3aW5kb3cuRWxlbWVudCkge1xuICAgIC8vIE5vdCBydW5uaW5nIGluIGEgYnJvd3NlciwgcHJvdmlkZSBhIGZhY3RvcnkgZnVuY3Rpb25cbiAgICAvLyBzbyB0aGF0IHlvdSBjYW4gcGFzcyB5b3VyIG93biBXaW5kb3dcbiAgICBET01QdXJpZnkuaXNTdXBwb3J0ZWQgPSBmYWxzZTtcbiAgICByZXR1cm4gRE9NUHVyaWZ5O1xuICB9XG4gIGxldCB7XG4gICAgZG9jdW1lbnRcbiAgfSA9IHdpbmRvdztcbiAgY29uc3Qgb3JpZ2luYWxEb2N1bWVudCA9IGRvY3VtZW50O1xuICBjb25zdCBjdXJyZW50U2NyaXB0ID0gb3JpZ2luYWxEb2N1bWVudC5jdXJyZW50U2NyaXB0O1xuICBjb25zdCB7XG4gICAgRG9jdW1lbnRGcmFnbWVudCxcbiAgICBIVE1MVGVtcGxhdGVFbGVtZW50LFxuICAgIE5vZGUsXG4gICAgRWxlbWVudCxcbiAgICBOb2RlRmlsdGVyLFxuICAgIE5hbWVkTm9kZU1hcCA9IHdpbmRvdy5OYW1lZE5vZGVNYXAgfHwgd2luZG93Lk1vek5hbWVkQXR0ck1hcCxcbiAgICBIVE1MRm9ybUVsZW1lbnQsXG4gICAgRE9NUGFyc2VyLFxuICAgIHRydXN0ZWRUeXBlc1xuICB9ID0gd2luZG93O1xuICBjb25zdCBFbGVtZW50UHJvdG90eXBlID0gRWxlbWVudC5wcm90b3R5cGU7XG4gIGNvbnN0IGNsb25lTm9kZSA9IGxvb2t1cEdldHRlcihFbGVtZW50UHJvdG90eXBlLCAnY2xvbmVOb2RlJyk7XG4gIGNvbnN0IHJlbW92ZSA9IGxvb2t1cEdldHRlcihFbGVtZW50UHJvdG90eXBlLCAncmVtb3ZlJyk7XG4gIGNvbnN0IGdldE5leHRTaWJsaW5nID0gbG9va3VwR2V0dGVyKEVsZW1lbnRQcm90b3R5cGUsICduZXh0U2libGluZycpO1xuICBjb25zdCBnZXRDaGlsZE5vZGVzID0gbG9va3VwR2V0dGVyKEVsZW1lbnRQcm90b3R5cGUsICdjaGlsZE5vZGVzJyk7XG4gIGNvbnN0IGdldFBhcmVudE5vZGUgPSBsb29rdXBHZXR0ZXIoRWxlbWVudFByb3RvdHlwZSwgJ3BhcmVudE5vZGUnKTtcbiAgLy8gQXMgcGVyIGlzc3VlICM0NywgdGhlIHdlYi1jb21wb25lbnRzIHJlZ2lzdHJ5IGlzIGluaGVyaXRlZCBieSBhXG4gIC8vIG5ldyBkb2N1bWVudCBjcmVhdGVkIHZpYSBjcmVhdGVIVE1MRG9jdW1lbnQuIEFzIHBlciB0aGUgc3BlY1xuICAvLyAoaHR0cDovL3czYy5naXRodWIuaW8vd2ViY29tcG9uZW50cy9zcGVjL2N1c3RvbS8jY3JlYXRpbmctYW5kLXBhc3NpbmctcmVnaXN0cmllcylcbiAgLy8gYSBuZXcgZW1wdHkgcmVnaXN0cnkgaXMgdXNlZCB3aGVuIGNyZWF0aW5nIGEgdGVtcGxhdGUgY29udGVudHMgb3duZXJcbiAgLy8gZG9jdW1lbnQsIHNvIHdlIHVzZSB0aGF0IGFzIG91ciBwYXJlbnQgZG9jdW1lbnQgdG8gZW5zdXJlIG5vdGhpbmdcbiAgLy8gaXMgaW5oZXJpdGVkLlxuICBpZiAodHlwZW9mIEhUTUxUZW1wbGF0ZUVsZW1lbnQgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjb25zdCB0ZW1wbGF0ZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3RlbXBsYXRlJyk7XG4gICAgaWYgKHRlbXBsYXRlLmNvbnRlbnQgJiYgdGVtcGxhdGUuY29udGVudC5vd25lckRvY3VtZW50KSB7XG4gICAgICBkb2N1bWVudCA9IHRlbXBsYXRlLmNvbnRlbnQub3duZXJEb2N1bWVudDtcbiAgICB9XG4gIH1cbiAgbGV0IHRydXN0ZWRUeXBlc1BvbGljeTtcbiAgbGV0IGVtcHR5SFRNTCA9ICcnO1xuICBjb25zdCB7XG4gICAgaW1wbGVtZW50YXRpb24sXG4gICAgY3JlYXRlTm9kZUl0ZXJhdG9yLFxuICAgIGNyZWF0ZURvY3VtZW50RnJhZ21lbnQsXG4gICAgZ2V0RWxlbWVudHNCeVRhZ05hbWVcbiAgfSA9IGRvY3VtZW50O1xuICBjb25zdCB7XG4gICAgaW1wb3J0Tm9kZVxuICB9ID0gb3JpZ2luYWxEb2N1bWVudDtcbiAgbGV0IGhvb2tzID0gX2NyZWF0ZUhvb2tzTWFwKCk7XG4gIC8qKlxuICAgKiBFeHBvc2Ugd2hldGhlciB0aGlzIGJyb3dzZXIgc3VwcG9ydHMgcnVubmluZyB0aGUgZnVsbCBET01QdXJpZnkuXG4gICAqL1xuICBET01QdXJpZnkuaXNTdXBwb3J0ZWQgPSB0eXBlb2YgZW50cmllcyA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgZ2V0UGFyZW50Tm9kZSA9PT0gJ2Z1bmN0aW9uJyAmJiBpbXBsZW1lbnRhdGlvbiAmJiBpbXBsZW1lbnRhdGlvbi5jcmVhdGVIVE1MRG9jdW1lbnQgIT09IHVuZGVmaW5lZDtcbiAgY29uc3Qge1xuICAgIE1VU1RBQ0hFX0VYUFIsXG4gICAgRVJCX0VYUFIsXG4gICAgVE1QTElUX0VYUFIsXG4gICAgREFUQV9BVFRSLFxuICAgIEFSSUFfQVRUUixcbiAgICBJU19TQ1JJUFRfT1JfREFUQSxcbiAgICBBVFRSX1dISVRFU1BBQ0UsXG4gICAgQ1VTVE9NX0VMRU1FTlRcbiAgfSA9IEVYUFJFU1NJT05TO1xuICBsZXQge1xuICAgIElTX0FMTE9XRURfVVJJOiBJU19BTExPV0VEX1VSSSQxXG4gIH0gPSBFWFBSRVNTSU9OUztcbiAgLyoqXG4gICAqIFdlIGNvbnNpZGVyIHRoZSBlbGVtZW50cyBhbmQgYXR0cmlidXRlcyBiZWxvdyB0byBiZSBzYWZlLiBJZGVhbGx5XG4gICAqIGRvbid0IGFkZCBhbnkgbmV3IG9uZXMgYnV0IGZlZWwgZnJlZSB0byByZW1vdmUgdW53YW50ZWQgb25lcy5cbiAgICovXG4gIC8qIGFsbG93ZWQgZWxlbWVudCBuYW1lcyAqL1xuICBsZXQgQUxMT1dFRF9UQUdTID0gbnVsbDtcbiAgY29uc3QgREVGQVVMVF9BTExPV0VEX1RBR1MgPSBhZGRUb1NldCh7fSwgWy4uLmh0bWwkMSwgLi4uc3ZnJDEsIC4uLnN2Z0ZpbHRlcnMsIC4uLm1hdGhNbCQxLCAuLi50ZXh0XSk7XG4gIC8qIEFsbG93ZWQgYXR0cmlidXRlIG5hbWVzICovXG4gIGxldCBBTExPV0VEX0FUVFIgPSBudWxsO1xuICBjb25zdCBERUZBVUxUX0FMTE9XRURfQVRUUiA9IGFkZFRvU2V0KHt9LCBbLi4uaHRtbCwgLi4uc3ZnLCAuLi5tYXRoTWwsIC4uLnhtbF0pO1xuICAvKlxuICAgKiBDb25maWd1cmUgaG93IERPTVB1cmlmeSBzaG91bGQgaGFuZGxlIGN1c3RvbSBlbGVtZW50cyBhbmQgdGhlaXIgYXR0cmlidXRlcyBhcyB3ZWxsIGFzIGN1c3RvbWl6ZWQgYnVpbHQtaW4gZWxlbWVudHMuXG4gICAqIEBwcm9wZXJ0eSB7UmVnRXhwfEZ1bmN0aW9ufG51bGx9IHRhZ05hbWVDaGVjayBvbmUgb2YgW251bGwsIHJlZ2V4UGF0dGVybiwgcHJlZGljYXRlXS4gRGVmYXVsdDogYG51bGxgIChkaXNhbGxvdyBhbnkgY3VzdG9tIGVsZW1lbnRzKVxuICAgKiBAcHJvcGVydHkge1JlZ0V4cHxGdW5jdGlvbnxudWxsfSBhdHRyaWJ1dGVOYW1lQ2hlY2sgb25lIG9mIFtudWxsLCByZWdleFBhdHRlcm4sIHByZWRpY2F0ZV0uIERlZmF1bHQ6IGBudWxsYCAoZGlzYWxsb3cgYW55IGF0dHJpYnV0ZXMgbm90IG9uIHRoZSBhbGxvdyBsaXN0KVxuICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IGFsbG93Q3VzdG9taXplZEJ1aWx0SW5FbGVtZW50cyBhbGxvdyBjdXN0b20gZWxlbWVudHMgZGVyaXZlZCBmcm9tIGJ1aWx0LWlucyBpZiB0aGV5IHBhc3MgQ1VTVE9NX0VMRU1FTlRfSEFORExJTkcudGFnTmFtZUNoZWNrLiBEZWZhdWx0OiBgZmFsc2VgLlxuICAgKi9cbiAgbGV0IENVU1RPTV9FTEVNRU5UX0hBTkRMSU5HID0gT2JqZWN0LnNlYWwoY3JlYXRlKG51bGwsIHtcbiAgICB0YWdOYW1lQ2hlY2s6IHtcbiAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgY29uZmlndXJhYmxlOiBmYWxzZSxcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICB2YWx1ZTogbnVsbFxuICAgIH0sXG4gICAgYXR0cmlidXRlTmFtZUNoZWNrOiB7XG4gICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgdmFsdWU6IG51bGxcbiAgICB9LFxuICAgIGFsbG93Q3VzdG9taXplZEJ1aWx0SW5FbGVtZW50czoge1xuICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IGZhbHNlLFxuICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgIHZhbHVlOiBmYWxzZVxuICAgIH1cbiAgfSkpO1xuICAvKiBFeHBsaWNpdGx5IGZvcmJpZGRlbiB0YWdzIChvdmVycmlkZXMgQUxMT1dFRF9UQUdTL0FERF9UQUdTKSAqL1xuICBsZXQgRk9SQklEX1RBR1MgPSBudWxsO1xuICAvKiBFeHBsaWNpdGx5IGZvcmJpZGRlbiBhdHRyaWJ1dGVzIChvdmVycmlkZXMgQUxMT1dFRF9BVFRSL0FERF9BVFRSKSAqL1xuICBsZXQgRk9SQklEX0FUVFIgPSBudWxsO1xuICAvKiBEZWNpZGUgaWYgQVJJQSBhdHRyaWJ1dGVzIGFyZSBva2F5ICovXG4gIGxldCBBTExPV19BUklBX0FUVFIgPSB0cnVlO1xuICAvKiBEZWNpZGUgaWYgY3VzdG9tIGRhdGEgYXR0cmlidXRlcyBhcmUgb2theSAqL1xuICBsZXQgQUxMT1dfREFUQV9BVFRSID0gdHJ1ZTtcbiAgLyogRGVjaWRlIGlmIHVua25vd24gcHJvdG9jb2xzIGFyZSBva2F5ICovXG4gIGxldCBBTExPV19VTktOT1dOX1BST1RPQ09MUyA9IGZhbHNlO1xuICAvKiBEZWNpZGUgaWYgc2VsZi1jbG9zaW5nIHRhZ3MgaW4gYXR0cmlidXRlcyBhcmUgYWxsb3dlZC5cbiAgICogVXN1YWxseSByZW1vdmVkIGR1ZSB0byBhIG1YU1MgaXNzdWUgaW4galF1ZXJ5IDMuMCAqL1xuICBsZXQgQUxMT1dfU0VMRl9DTE9TRV9JTl9BVFRSID0gdHJ1ZTtcbiAgLyogT3V0cHV0IHNob3VsZCBiZSBzYWZlIGZvciBjb21tb24gdGVtcGxhdGUgZW5naW5lcy5cbiAgICogVGhpcyBtZWFucywgRE9NUHVyaWZ5IHJlbW92ZXMgZGF0YSBhdHRyaWJ1dGVzLCBtdXN0YWNoZXMgYW5kIEVSQlxuICAgKi9cbiAgbGV0IFNBRkVfRk9SX1RFTVBMQVRFUyA9IGZhbHNlO1xuICAvKiBPdXRwdXQgc2hvdWxkIGJlIHNhZmUgZXZlbiBmb3IgWE1MIHVzZWQgd2l0aGluIEhUTUwgYW5kIGFsaWtlLlxuICAgKiBUaGlzIG1lYW5zLCBET01QdXJpZnkgcmVtb3ZlcyBjb21tZW50cyB3aGVuIGNvbnRhaW5pbmcgcmlza3kgY29udGVudC5cbiAgICovXG4gIGxldCBTQUZFX0ZPUl9YTUwgPSB0cnVlO1xuICAvKiBEZWNpZGUgaWYgZG9jdW1lbnQgd2l0aCA8aHRtbD4uLi4gc2hvdWxkIGJlIHJldHVybmVkICovXG4gIGxldCBXSE9MRV9ET0NVTUVOVCA9IGZhbHNlO1xuICAvKiBUcmFjayB3aGV0aGVyIGNvbmZpZyBpcyBhbHJlYWR5IHNldCBvbiB0aGlzIGluc3RhbmNlIG9mIERPTVB1cmlmeS4gKi9cbiAgbGV0IFNFVF9DT05GSUcgPSBmYWxzZTtcbiAgLyogRGVjaWRlIGlmIGFsbCBlbGVtZW50cyAoZS5nLiBzdHlsZSwgc2NyaXB0KSBtdXN0IGJlIGNoaWxkcmVuIG9mXG4gICAqIGRvY3VtZW50LmJvZHkuIEJ5IGRlZmF1bHQsIGJyb3dzZXJzIG1pZ2h0IG1vdmUgdGhlbSB0byBkb2N1bWVudC5oZWFkICovXG4gIGxldCBGT1JDRV9CT0RZID0gZmFsc2U7XG4gIC8qIERlY2lkZSBpZiBhIERPTSBgSFRNTEJvZHlFbGVtZW50YCBzaG91bGQgYmUgcmV0dXJuZWQsIGluc3RlYWQgb2YgYSBodG1sXG4gICAqIHN0cmluZyAob3IgYSBUcnVzdGVkSFRNTCBvYmplY3QgaWYgVHJ1c3RlZCBUeXBlcyBhcmUgc3VwcG9ydGVkKS5cbiAgICogSWYgYFdIT0xFX0RPQ1VNRU5UYCBpcyBlbmFibGVkIGEgYEhUTUxIdG1sRWxlbWVudGAgd2lsbCBiZSByZXR1cm5lZCBpbnN0ZWFkXG4gICAqL1xuICBsZXQgUkVUVVJOX0RPTSA9IGZhbHNlO1xuICAvKiBEZWNpZGUgaWYgYSBET00gYERvY3VtZW50RnJhZ21lbnRgIHNob3VsZCBiZSByZXR1cm5lZCwgaW5zdGVhZCBvZiBhIGh0bWxcbiAgICogc3RyaW5nICAob3IgYSBUcnVzdGVkSFRNTCBvYmplY3QgaWYgVHJ1c3RlZCBUeXBlcyBhcmUgc3VwcG9ydGVkKSAqL1xuICBsZXQgUkVUVVJOX0RPTV9GUkFHTUVOVCA9IGZhbHNlO1xuICAvKiBUcnkgdG8gcmV0dXJuIGEgVHJ1c3RlZCBUeXBlIG9iamVjdCBpbnN0ZWFkIG9mIGEgc3RyaW5nLCByZXR1cm4gYSBzdHJpbmcgaW5cbiAgICogY2FzZSBUcnVzdGVkIFR5cGVzIGFyZSBub3Qgc3VwcG9ydGVkICAqL1xuICBsZXQgUkVUVVJOX1RSVVNURURfVFlQRSA9IGZhbHNlO1xuICAvKiBPdXRwdXQgc2hvdWxkIGJlIGZyZWUgZnJvbSBET00gY2xvYmJlcmluZyBhdHRhY2tzP1xuICAgKiBUaGlzIHNhbml0aXplcyBtYXJrdXBzIG5hbWVkIHdpdGggY29sbGlkaW5nLCBjbG9iYmVyYWJsZSBidWlsdC1pbiBET00gQVBJcy5cbiAgICovXG4gIGxldCBTQU5JVElaRV9ET00gPSB0cnVlO1xuICAvKiBBY2hpZXZlIGZ1bGwgRE9NIENsb2JiZXJpbmcgcHJvdGVjdGlvbiBieSBpc29sYXRpbmcgdGhlIG5hbWVzcGFjZSBvZiBuYW1lZFxuICAgKiBwcm9wZXJ0aWVzIGFuZCBKUyB2YXJpYWJsZXMsIG1pdGlnYXRpbmcgYXR0YWNrcyB0aGF0IGFidXNlIHRoZSBIVE1ML0RPTSBzcGVjIHJ1bGVzLlxuICAgKlxuICAgKiBIVE1ML0RPTSBzcGVjIHJ1bGVzIHRoYXQgZW5hYmxlIERPTSBDbG9iYmVyaW5nOlxuICAgKiAgIC0gTmFtZWQgQWNjZXNzIG9uIFdpbmRvdyAowqc3LjMuMylcbiAgICogICAtIERPTSBUcmVlIEFjY2Vzc29ycyAowqczLjEuNSlcbiAgICogICAtIEZvcm0gRWxlbWVudCBQYXJlbnQtQ2hpbGQgUmVsYXRpb25zICjCpzQuMTAuMylcbiAgICogICAtIElmcmFtZSBzcmNkb2MgLyBOZXN0ZWQgV2luZG93UHJveGllcyAowqc0LjguNSlcbiAgICogICAtIEhUTUxDb2xsZWN0aW9uICjCpzQuMi4xMC4yKVxuICAgKlxuICAgKiBOYW1lc3BhY2UgaXNvbGF0aW9uIGlzIGltcGxlbWVudGVkIGJ5IHByZWZpeGluZyBgaWRgIGFuZCBgbmFtZWAgYXR0cmlidXRlc1xuICAgKiB3aXRoIGEgY29uc3RhbnQgc3RyaW5nLCBpLmUuLCBgdXNlci1jb250ZW50LWBcbiAgICovXG4gIGxldCBTQU5JVElaRV9OQU1FRF9QUk9QUyA9IGZhbHNlO1xuICBjb25zdCBTQU5JVElaRV9OQU1FRF9QUk9QU19QUkVGSVggPSAndXNlci1jb250ZW50LSc7XG4gIC8qIEtlZXAgZWxlbWVudCBjb250ZW50IHdoZW4gcmVtb3ZpbmcgZWxlbWVudD8gKi9cbiAgbGV0IEtFRVBfQ09OVEVOVCA9IHRydWU7XG4gIC8qIElmIGEgYE5vZGVgIGlzIHBhc3NlZCB0byBzYW5pdGl6ZSgpLCB0aGVuIHBlcmZvcm1zIHNhbml0aXphdGlvbiBpbi1wbGFjZSBpbnN0ZWFkXG4gICAqIG9mIGltcG9ydGluZyBpdCBpbnRvIGEgbmV3IERvY3VtZW50IGFuZCByZXR1cm5pbmcgYSBzYW5pdGl6ZWQgY29weSAqL1xuICBsZXQgSU5fUExBQ0UgPSBmYWxzZTtcbiAgLyogQWxsb3cgdXNhZ2Ugb2YgcHJvZmlsZXMgbGlrZSBodG1sLCBzdmcgYW5kIG1hdGhNbCAqL1xuICBsZXQgVVNFX1BST0ZJTEVTID0ge307XG4gIC8qIFRhZ3MgdG8gaWdub3JlIGNvbnRlbnQgb2Ygd2hlbiBLRUVQX0NPTlRFTlQgaXMgdHJ1ZSAqL1xuICBsZXQgRk9SQklEX0NPTlRFTlRTID0gbnVsbDtcbiAgY29uc3QgREVGQVVMVF9GT1JCSURfQ09OVEVOVFMgPSBhZGRUb1NldCh7fSwgWydhbm5vdGF0aW9uLXhtbCcsICdhdWRpbycsICdjb2xncm91cCcsICdkZXNjJywgJ2ZvcmVpZ25vYmplY3QnLCAnaGVhZCcsICdpZnJhbWUnLCAnbWF0aCcsICdtaScsICdtbicsICdtbycsICdtcycsICdtdGV4dCcsICdub2VtYmVkJywgJ25vZnJhbWVzJywgJ25vc2NyaXB0JywgJ3BsYWludGV4dCcsICdzY3JpcHQnLCAnc3R5bGUnLCAnc3ZnJywgJ3RlbXBsYXRlJywgJ3RoZWFkJywgJ3RpdGxlJywgJ3ZpZGVvJywgJ3htcCddKTtcbiAgLyogVGFncyB0aGF0IGFyZSBzYWZlIGZvciBkYXRhOiBVUklzICovXG4gIGxldCBEQVRBX1VSSV9UQUdTID0gbnVsbDtcbiAgY29uc3QgREVGQVVMVF9EQVRBX1VSSV9UQUdTID0gYWRkVG9TZXQoe30sIFsnYXVkaW8nLCAndmlkZW8nLCAnaW1nJywgJ3NvdXJjZScsICdpbWFnZScsICd0cmFjayddKTtcbiAgLyogQXR0cmlidXRlcyBzYWZlIGZvciB2YWx1ZXMgbGlrZSBcImphdmFzY3JpcHQ6XCIgKi9cbiAgbGV0IFVSSV9TQUZFX0FUVFJJQlVURVMgPSBudWxsO1xuICBjb25zdCBERUZBVUxUX1VSSV9TQUZFX0FUVFJJQlVURVMgPSBhZGRUb1NldCh7fSwgWydhbHQnLCAnY2xhc3MnLCAnZm9yJywgJ2lkJywgJ2xhYmVsJywgJ25hbWUnLCAncGF0dGVybicsICdwbGFjZWhvbGRlcicsICdyb2xlJywgJ3N1bW1hcnknLCAndGl0bGUnLCAndmFsdWUnLCAnc3R5bGUnLCAneG1sbnMnXSk7XG4gIGNvbnN0IE1BVEhNTF9OQU1FU1BBQ0UgPSAnaHR0cDovL3d3dy53My5vcmcvMTk5OC9NYXRoL01hdGhNTCc7XG4gIGNvbnN0IFNWR19OQU1FU1BBQ0UgPSAnaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnO1xuICBjb25zdCBIVE1MX05BTUVTUEFDRSA9ICdodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hodG1sJztcbiAgLyogRG9jdW1lbnQgbmFtZXNwYWNlICovXG4gIGxldCBOQU1FU1BBQ0UgPSBIVE1MX05BTUVTUEFDRTtcbiAgbGV0IElTX0VNUFRZX0lOUFVUID0gZmFsc2U7XG4gIC8qIEFsbG93ZWQgWEhUTUwrWE1MIG5hbWVzcGFjZXMgKi9cbiAgbGV0IEFMTE9XRURfTkFNRVNQQUNFUyA9IG51bGw7XG4gIGNvbnN0IERFRkFVTFRfQUxMT1dFRF9OQU1FU1BBQ0VTID0gYWRkVG9TZXQoe30sIFtNQVRITUxfTkFNRVNQQUNFLCBTVkdfTkFNRVNQQUNFLCBIVE1MX05BTUVTUEFDRV0sIHN0cmluZ1RvU3RyaW5nKTtcbiAgbGV0IE1BVEhNTF9URVhUX0lOVEVHUkFUSU9OX1BPSU5UUyA9IGFkZFRvU2V0KHt9LCBbJ21pJywgJ21vJywgJ21uJywgJ21zJywgJ210ZXh0J10pO1xuICBsZXQgSFRNTF9JTlRFR1JBVElPTl9QT0lOVFMgPSBhZGRUb1NldCh7fSwgWydhbm5vdGF0aW9uLXhtbCddKTtcbiAgLy8gQ2VydGFpbiBlbGVtZW50cyBhcmUgYWxsb3dlZCBpbiBib3RoIFNWRyBhbmQgSFRNTFxuICAvLyBuYW1lc3BhY2UuIFdlIG5lZWQgdG8gc3BlY2lmeSB0aGVtIGV4cGxpY2l0bHlcbiAgLy8gc28gdGhhdCB0aGV5IGRvbid0IGdldCBlcnJvbmVvdXNseSBkZWxldGVkIGZyb21cbiAgLy8gSFRNTCBuYW1lc3BhY2UuXG4gIGNvbnN0IENPTU1PTl9TVkdfQU5EX0hUTUxfRUxFTUVOVFMgPSBhZGRUb1NldCh7fSwgWyd0aXRsZScsICdzdHlsZScsICdmb250JywgJ2EnLCAnc2NyaXB0J10pO1xuICAvKiBQYXJzaW5nIG9mIHN0cmljdCBYSFRNTCBkb2N1bWVudHMgKi9cbiAgbGV0IFBBUlNFUl9NRURJQV9UWVBFID0gbnVsbDtcbiAgY29uc3QgU1VQUE9SVEVEX1BBUlNFUl9NRURJQV9UWVBFUyA9IFsnYXBwbGljYXRpb24veGh0bWwreG1sJywgJ3RleHQvaHRtbCddO1xuICBjb25zdCBERUZBVUxUX1BBUlNFUl9NRURJQV9UWVBFID0gJ3RleHQvaHRtbCc7XG4gIGxldCB0cmFuc2Zvcm1DYXNlRnVuYyA9IG51bGw7XG4gIC8qIEtlZXAgYSByZWZlcmVuY2UgdG8gY29uZmlnIHRvIHBhc3MgdG8gaG9va3MgKi9cbiAgbGV0IENPTkZJRyA9IG51bGw7XG4gIC8qIElkZWFsbHksIGRvIG5vdCB0b3VjaCBhbnl0aGluZyBiZWxvdyB0aGlzIGxpbmUgKi9cbiAgLyogX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fXyAqL1xuICBjb25zdCBmb3JtRWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2Zvcm0nKTtcbiAgY29uc3QgaXNSZWdleE9yRnVuY3Rpb24gPSBmdW5jdGlvbiBpc1JlZ2V4T3JGdW5jdGlvbih0ZXN0VmFsdWUpIHtcbiAgICByZXR1cm4gdGVzdFZhbHVlIGluc3RhbmNlb2YgUmVnRXhwIHx8IHRlc3RWYWx1ZSBpbnN0YW5jZW9mIEZ1bmN0aW9uO1xuICB9O1xuICAvKipcbiAgICogX3BhcnNlQ29uZmlnXG4gICAqXG4gICAqIEBwYXJhbSBjZmcgb3B0aW9uYWwgY29uZmlnIGxpdGVyYWxcbiAgICovXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBjb21wbGV4aXR5XG4gIGNvbnN0IF9wYXJzZUNvbmZpZyA9IGZ1bmN0aW9uIF9wYXJzZUNvbmZpZygpIHtcbiAgICBsZXQgY2ZnID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcbiAgICBpZiAoQ09ORklHICYmIENPTkZJRyA9PT0gY2ZnKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIC8qIFNoaWVsZCBjb25maWd1cmF0aW9uIG9iamVjdCBmcm9tIHRhbXBlcmluZyAqL1xuICAgIGlmICghY2ZnIHx8IHR5cGVvZiBjZmcgIT09ICdvYmplY3QnKSB7XG4gICAgICBjZmcgPSB7fTtcbiAgICB9XG4gICAgLyogU2hpZWxkIGNvbmZpZ3VyYXRpb24gb2JqZWN0IGZyb20gcHJvdG90eXBlIHBvbGx1dGlvbiAqL1xuICAgIGNmZyA9IGNsb25lKGNmZyk7XG4gICAgUEFSU0VSX01FRElBX1RZUEUgPVxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSB1bmljb3JuL3ByZWZlci1pbmNsdWRlc1xuICAgIFNVUFBPUlRFRF9QQVJTRVJfTUVESUFfVFlQRVMuaW5kZXhPZihjZmcuUEFSU0VSX01FRElBX1RZUEUpID09PSAtMSA/IERFRkFVTFRfUEFSU0VSX01FRElBX1RZUEUgOiBjZmcuUEFSU0VSX01FRElBX1RZUEU7XG4gICAgLy8gSFRNTCB0YWdzIGFuZCBhdHRyaWJ1dGVzIGFyZSBub3QgY2FzZS1zZW5zaXRpdmUsIGNvbnZlcnRpbmcgdG8gbG93ZXJjYXNlLiBLZWVwaW5nIFhIVE1MIGFzIGlzLlxuICAgIHRyYW5zZm9ybUNhc2VGdW5jID0gUEFSU0VSX01FRElBX1RZUEUgPT09ICdhcHBsaWNhdGlvbi94aHRtbCt4bWwnID8gc3RyaW5nVG9TdHJpbmcgOiBzdHJpbmdUb0xvd2VyQ2FzZTtcbiAgICAvKiBTZXQgY29uZmlndXJhdGlvbiBwYXJhbWV0ZXJzICovXG4gICAgQUxMT1dFRF9UQUdTID0gb2JqZWN0SGFzT3duUHJvcGVydHkoY2ZnLCAnQUxMT1dFRF9UQUdTJykgPyBhZGRUb1NldCh7fSwgY2ZnLkFMTE9XRURfVEFHUywgdHJhbnNmb3JtQ2FzZUZ1bmMpIDogREVGQVVMVF9BTExPV0VEX1RBR1M7XG4gICAgQUxMT1dFRF9BVFRSID0gb2JqZWN0SGFzT3duUHJvcGVydHkoY2ZnLCAnQUxMT1dFRF9BVFRSJykgPyBhZGRUb1NldCh7fSwgY2ZnLkFMTE9XRURfQVRUUiwgdHJhbnNmb3JtQ2FzZUZ1bmMpIDogREVGQVVMVF9BTExPV0VEX0FUVFI7XG4gICAgQUxMT1dFRF9OQU1FU1BBQ0VTID0gb2JqZWN0SGFzT3duUHJvcGVydHkoY2ZnLCAnQUxMT1dFRF9OQU1FU1BBQ0VTJykgPyBhZGRUb1NldCh7fSwgY2ZnLkFMTE9XRURfTkFNRVNQQUNFUywgc3RyaW5nVG9TdHJpbmcpIDogREVGQVVMVF9BTExPV0VEX05BTUVTUEFDRVM7XG4gICAgVVJJX1NBRkVfQVRUUklCVVRFUyA9IG9iamVjdEhhc093blByb3BlcnR5KGNmZywgJ0FERF9VUklfU0FGRV9BVFRSJykgPyBhZGRUb1NldChjbG9uZShERUZBVUxUX1VSSV9TQUZFX0FUVFJJQlVURVMpLCBjZmcuQUREX1VSSV9TQUZFX0FUVFIsIHRyYW5zZm9ybUNhc2VGdW5jKSA6IERFRkFVTFRfVVJJX1NBRkVfQVRUUklCVVRFUztcbiAgICBEQVRBX1VSSV9UQUdTID0gb2JqZWN0SGFzT3duUHJvcGVydHkoY2ZnLCAnQUREX0RBVEFfVVJJX1RBR1MnKSA/IGFkZFRvU2V0KGNsb25lKERFRkFVTFRfREFUQV9VUklfVEFHUyksIGNmZy5BRERfREFUQV9VUklfVEFHUywgdHJhbnNmb3JtQ2FzZUZ1bmMpIDogREVGQVVMVF9EQVRBX1VSSV9UQUdTO1xuICAgIEZPUkJJRF9DT05URU5UUyA9IG9iamVjdEhhc093blByb3BlcnR5KGNmZywgJ0ZPUkJJRF9DT05URU5UUycpID8gYWRkVG9TZXQoe30sIGNmZy5GT1JCSURfQ09OVEVOVFMsIHRyYW5zZm9ybUNhc2VGdW5jKSA6IERFRkFVTFRfRk9SQklEX0NPTlRFTlRTO1xuICAgIEZPUkJJRF9UQUdTID0gb2JqZWN0SGFzT3duUHJvcGVydHkoY2ZnLCAnRk9SQklEX1RBR1MnKSA/IGFkZFRvU2V0KHt9LCBjZmcuRk9SQklEX1RBR1MsIHRyYW5zZm9ybUNhc2VGdW5jKSA6IHt9O1xuICAgIEZPUkJJRF9BVFRSID0gb2JqZWN0SGFzT3duUHJvcGVydHkoY2ZnLCAnRk9SQklEX0FUVFInKSA/IGFkZFRvU2V0KHt9LCBjZmcuRk9SQklEX0FUVFIsIHRyYW5zZm9ybUNhc2VGdW5jKSA6IHt9O1xuICAgIFVTRV9QUk9GSUxFUyA9IG9iamVjdEhhc093blByb3BlcnR5KGNmZywgJ1VTRV9QUk9GSUxFUycpID8gY2ZnLlVTRV9QUk9GSUxFUyA6IGZhbHNlO1xuICAgIEFMTE9XX0FSSUFfQVRUUiA9IGNmZy5BTExPV19BUklBX0FUVFIgIT09IGZhbHNlOyAvLyBEZWZhdWx0IHRydWVcbiAgICBBTExPV19EQVRBX0FUVFIgPSBjZmcuQUxMT1dfREFUQV9BVFRSICE9PSBmYWxzZTsgLy8gRGVmYXVsdCB0cnVlXG4gICAgQUxMT1dfVU5LTk9XTl9QUk9UT0NPTFMgPSBjZmcuQUxMT1dfVU5LTk9XTl9QUk9UT0NPTFMgfHwgZmFsc2U7IC8vIERlZmF1bHQgZmFsc2VcbiAgICBBTExPV19TRUxGX0NMT1NFX0lOX0FUVFIgPSBjZmcuQUxMT1dfU0VMRl9DTE9TRV9JTl9BVFRSICE9PSBmYWxzZTsgLy8gRGVmYXVsdCB0cnVlXG4gICAgU0FGRV9GT1JfVEVNUExBVEVTID0gY2ZnLlNBRkVfRk9SX1RFTVBMQVRFUyB8fCBmYWxzZTsgLy8gRGVmYXVsdCBmYWxzZVxuICAgIFNBRkVfRk9SX1hNTCA9IGNmZy5TQUZFX0ZPUl9YTUwgIT09IGZhbHNlOyAvLyBEZWZhdWx0IHRydWVcbiAgICBXSE9MRV9ET0NVTUVOVCA9IGNmZy5XSE9MRV9ET0NVTUVOVCB8fCBmYWxzZTsgLy8gRGVmYXVsdCBmYWxzZVxuICAgIFJFVFVSTl9ET00gPSBjZmcuUkVUVVJOX0RPTSB8fCBmYWxzZTsgLy8gRGVmYXVsdCBmYWxzZVxuICAgIFJFVFVSTl9ET01fRlJBR01FTlQgPSBjZmcuUkVUVVJOX0RPTV9GUkFHTUVOVCB8fCBmYWxzZTsgLy8gRGVmYXVsdCBmYWxzZVxuICAgIFJFVFVSTl9UUlVTVEVEX1RZUEUgPSBjZmcuUkVUVVJOX1RSVVNURURfVFlQRSB8fCBmYWxzZTsgLy8gRGVmYXVsdCBmYWxzZVxuICAgIEZPUkNFX0JPRFkgPSBjZmcuRk9SQ0VfQk9EWSB8fCBmYWxzZTsgLy8gRGVmYXVsdCBmYWxzZVxuICAgIFNBTklUSVpFX0RPTSA9IGNmZy5TQU5JVElaRV9ET00gIT09IGZhbHNlOyAvLyBEZWZhdWx0IHRydWVcbiAgICBTQU5JVElaRV9OQU1FRF9QUk9QUyA9IGNmZy5TQU5JVElaRV9OQU1FRF9QUk9QUyB8fCBmYWxzZTsgLy8gRGVmYXVsdCBmYWxzZVxuICAgIEtFRVBfQ09OVEVOVCA9IGNmZy5LRUVQX0NPTlRFTlQgIT09IGZhbHNlOyAvLyBEZWZhdWx0IHRydWVcbiAgICBJTl9QTEFDRSA9IGNmZy5JTl9QTEFDRSB8fCBmYWxzZTsgLy8gRGVmYXVsdCBmYWxzZVxuICAgIElTX0FMTE9XRURfVVJJJDEgPSBjZmcuQUxMT1dFRF9VUklfUkVHRVhQIHx8IElTX0FMTE9XRURfVVJJO1xuICAgIE5BTUVTUEFDRSA9IGNmZy5OQU1FU1BBQ0UgfHwgSFRNTF9OQU1FU1BBQ0U7XG4gICAgTUFUSE1MX1RFWFRfSU5URUdSQVRJT05fUE9JTlRTID0gY2ZnLk1BVEhNTF9URVhUX0lOVEVHUkFUSU9OX1BPSU5UUyB8fCBNQVRITUxfVEVYVF9JTlRFR1JBVElPTl9QT0lOVFM7XG4gICAgSFRNTF9JTlRFR1JBVElPTl9QT0lOVFMgPSBjZmcuSFRNTF9JTlRFR1JBVElPTl9QT0lOVFMgfHwgSFRNTF9JTlRFR1JBVElPTl9QT0lOVFM7XG4gICAgQ1VTVE9NX0VMRU1FTlRfSEFORExJTkcgPSBjZmcuQ1VTVE9NX0VMRU1FTlRfSEFORExJTkcgfHwge307XG4gICAgaWYgKGNmZy5DVVNUT01fRUxFTUVOVF9IQU5ETElORyAmJiBpc1JlZ2V4T3JGdW5jdGlvbihjZmcuQ1VTVE9NX0VMRU1FTlRfSEFORExJTkcudGFnTmFtZUNoZWNrKSkge1xuICAgICAgQ1VTVE9NX0VMRU1FTlRfSEFORExJTkcudGFnTmFtZUNoZWNrID0gY2ZnLkNVU1RPTV9FTEVNRU5UX0hBTkRMSU5HLnRhZ05hbWVDaGVjaztcbiAgICB9XG4gICAgaWYgKGNmZy5DVVNUT01fRUxFTUVOVF9IQU5ETElORyAmJiBpc1JlZ2V4T3JGdW5jdGlvbihjZmcuQ1VTVE9NX0VMRU1FTlRfSEFORExJTkcuYXR0cmlidXRlTmFtZUNoZWNrKSkge1xuICAgICAgQ1VTVE9NX0VMRU1FTlRfSEFORExJTkcuYXR0cmlidXRlTmFtZUNoZWNrID0gY2ZnLkNVU1RPTV9FTEVNRU5UX0hBTkRMSU5HLmF0dHJpYnV0ZU5hbWVDaGVjaztcbiAgICB9XG4gICAgaWYgKGNmZy5DVVNUT01fRUxFTUVOVF9IQU5ETElORyAmJiB0eXBlb2YgY2ZnLkNVU1RPTV9FTEVNRU5UX0hBTkRMSU5HLmFsbG93Q3VzdG9taXplZEJ1aWx0SW5FbGVtZW50cyA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICBDVVNUT01fRUxFTUVOVF9IQU5ETElORy5hbGxvd0N1c3RvbWl6ZWRCdWlsdEluRWxlbWVudHMgPSBjZmcuQ1VTVE9NX0VMRU1FTlRfSEFORExJTkcuYWxsb3dDdXN0b21pemVkQnVpbHRJbkVsZW1lbnRzO1xuICAgIH1cbiAgICBpZiAoU0FGRV9GT1JfVEVNUExBVEVTKSB7XG4gICAgICBBTExPV19EQVRBX0FUVFIgPSBmYWxzZTtcbiAgICB9XG4gICAgaWYgKFJFVFVSTl9ET01fRlJBR01FTlQpIHtcbiAgICAgIFJFVFVSTl9ET00gPSB0cnVlO1xuICAgIH1cbiAgICAvKiBQYXJzZSBwcm9maWxlIGluZm8gKi9cbiAgICBpZiAoVVNFX1BST0ZJTEVTKSB7XG4gICAgICBBTExPV0VEX1RBR1MgPSBhZGRUb1NldCh7fSwgdGV4dCk7XG4gICAgICBBTExPV0VEX0FUVFIgPSBbXTtcbiAgICAgIGlmIChVU0VfUFJPRklMRVMuaHRtbCA9PT0gdHJ1ZSkge1xuICAgICAgICBhZGRUb1NldChBTExPV0VEX1RBR1MsIGh0bWwkMSk7XG4gICAgICAgIGFkZFRvU2V0KEFMTE9XRURfQVRUUiwgaHRtbCk7XG4gICAgICB9XG4gICAgICBpZiAoVVNFX1BST0ZJTEVTLnN2ZyA9PT0gdHJ1ZSkge1xuICAgICAgICBhZGRUb1NldChBTExPV0VEX1RBR1MsIHN2ZyQxKTtcbiAgICAgICAgYWRkVG9TZXQoQUxMT1dFRF9BVFRSLCBzdmcpO1xuICAgICAgICBhZGRUb1NldChBTExPV0VEX0FUVFIsIHhtbCk7XG4gICAgICB9XG4gICAgICBpZiAoVVNFX1BST0ZJTEVTLnN2Z0ZpbHRlcnMgPT09IHRydWUpIHtcbiAgICAgICAgYWRkVG9TZXQoQUxMT1dFRF9UQUdTLCBzdmdGaWx0ZXJzKTtcbiAgICAgICAgYWRkVG9TZXQoQUxMT1dFRF9BVFRSLCBzdmcpO1xuICAgICAgICBhZGRUb1NldChBTExPV0VEX0FUVFIsIHhtbCk7XG4gICAgICB9XG4gICAgICBpZiAoVVNFX1BST0ZJTEVTLm1hdGhNbCA9PT0gdHJ1ZSkge1xuICAgICAgICBhZGRUb1NldChBTExPV0VEX1RBR1MsIG1hdGhNbCQxKTtcbiAgICAgICAgYWRkVG9TZXQoQUxMT1dFRF9BVFRSLCBtYXRoTWwpO1xuICAgICAgICBhZGRUb1NldChBTExPV0VEX0FUVFIsIHhtbCk7XG4gICAgICB9XG4gICAgfVxuICAgIC8qIE1lcmdlIGNvbmZpZ3VyYXRpb24gcGFyYW1ldGVycyAqL1xuICAgIGlmIChjZmcuQUREX1RBR1MpIHtcbiAgICAgIGlmIChBTExPV0VEX1RBR1MgPT09IERFRkFVTFRfQUxMT1dFRF9UQUdTKSB7XG4gICAgICAgIEFMTE9XRURfVEFHUyA9IGNsb25lKEFMTE9XRURfVEFHUyk7XG4gICAgICB9XG4gICAgICBhZGRUb1NldChBTExPV0VEX1RBR1MsIGNmZy5BRERfVEFHUywgdHJhbnNmb3JtQ2FzZUZ1bmMpO1xuICAgIH1cbiAgICBpZiAoY2ZnLkFERF9BVFRSKSB7XG4gICAgICBpZiAoQUxMT1dFRF9BVFRSID09PSBERUZBVUxUX0FMTE9XRURfQVRUUikge1xuICAgICAgICBBTExPV0VEX0FUVFIgPSBjbG9uZShBTExPV0VEX0FUVFIpO1xuICAgICAgfVxuICAgICAgYWRkVG9TZXQoQUxMT1dFRF9BVFRSLCBjZmcuQUREX0FUVFIsIHRyYW5zZm9ybUNhc2VGdW5jKTtcbiAgICB9XG4gICAgaWYgKGNmZy5BRERfVVJJX1NBRkVfQVRUUikge1xuICAgICAgYWRkVG9TZXQoVVJJX1NBRkVfQVRUUklCVVRFUywgY2ZnLkFERF9VUklfU0FGRV9BVFRSLCB0cmFuc2Zvcm1DYXNlRnVuYyk7XG4gICAgfVxuICAgIGlmIChjZmcuRk9SQklEX0NPTlRFTlRTKSB7XG4gICAgICBpZiAoRk9SQklEX0NPTlRFTlRTID09PSBERUZBVUxUX0ZPUkJJRF9DT05URU5UUykge1xuICAgICAgICBGT1JCSURfQ09OVEVOVFMgPSBjbG9uZShGT1JCSURfQ09OVEVOVFMpO1xuICAgICAgfVxuICAgICAgYWRkVG9TZXQoRk9SQklEX0NPTlRFTlRTLCBjZmcuRk9SQklEX0NPTlRFTlRTLCB0cmFuc2Zvcm1DYXNlRnVuYyk7XG4gICAgfVxuICAgIC8qIEFkZCAjdGV4dCBpbiBjYXNlIEtFRVBfQ09OVEVOVCBpcyBzZXQgdG8gdHJ1ZSAqL1xuICAgIGlmIChLRUVQX0NPTlRFTlQpIHtcbiAgICAgIEFMTE9XRURfVEFHU1snI3RleHQnXSA9IHRydWU7XG4gICAgfVxuICAgIC8qIEFkZCBodG1sLCBoZWFkIGFuZCBib2R5IHRvIEFMTE9XRURfVEFHUyBpbiBjYXNlIFdIT0xFX0RPQ1VNRU5UIGlzIHRydWUgKi9cbiAgICBpZiAoV0hPTEVfRE9DVU1FTlQpIHtcbiAgICAgIGFkZFRvU2V0KEFMTE9XRURfVEFHUywgWydodG1sJywgJ2hlYWQnLCAnYm9keSddKTtcbiAgICB9XG4gICAgLyogQWRkIHRib2R5IHRvIEFMTE9XRURfVEFHUyBpbiBjYXNlIHRhYmxlcyBhcmUgcGVybWl0dGVkLCBzZWUgIzI4NiwgIzM2NSAqL1xuICAgIGlmIChBTExPV0VEX1RBR1MudGFibGUpIHtcbiAgICAgIGFkZFRvU2V0KEFMTE9XRURfVEFHUywgWyd0Ym9keSddKTtcbiAgICAgIGRlbGV0ZSBGT1JCSURfVEFHUy50Ym9keTtcbiAgICB9XG4gICAgaWYgKGNmZy5UUlVTVEVEX1RZUEVTX1BPTElDWSkge1xuICAgICAgaWYgKHR5cGVvZiBjZmcuVFJVU1RFRF9UWVBFU19QT0xJQ1kuY3JlYXRlSFRNTCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0aHJvdyB0eXBlRXJyb3JDcmVhdGUoJ1RSVVNURURfVFlQRVNfUE9MSUNZIGNvbmZpZ3VyYXRpb24gb3B0aW9uIG11c3QgcHJvdmlkZSBhIFwiY3JlYXRlSFRNTFwiIGhvb2suJyk7XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIGNmZy5UUlVTVEVEX1RZUEVTX1BPTElDWS5jcmVhdGVTY3JpcHRVUkwgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdGhyb3cgdHlwZUVycm9yQ3JlYXRlKCdUUlVTVEVEX1RZUEVTX1BPTElDWSBjb25maWd1cmF0aW9uIG9wdGlvbiBtdXN0IHByb3ZpZGUgYSBcImNyZWF0ZVNjcmlwdFVSTFwiIGhvb2suJyk7XG4gICAgICB9XG4gICAgICAvLyBPdmVyd3JpdGUgZXhpc3RpbmcgVHJ1c3RlZFR5cGVzIHBvbGljeS5cbiAgICAgIHRydXN0ZWRUeXBlc1BvbGljeSA9IGNmZy5UUlVTVEVEX1RZUEVTX1BPTElDWTtcbiAgICAgIC8vIFNpZ24gbG9jYWwgdmFyaWFibGVzIHJlcXVpcmVkIGJ5IGBzYW5pdGl6ZWAuXG4gICAgICBlbXB0eUhUTUwgPSB0cnVzdGVkVHlwZXNQb2xpY3kuY3JlYXRlSFRNTCgnJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFVuaW5pdGlhbGl6ZWQgcG9saWN5LCBhdHRlbXB0IHRvIGluaXRpYWxpemUgdGhlIGludGVybmFsIGRvbXB1cmlmeSBwb2xpY3kuXG4gICAgICBpZiAodHJ1c3RlZFR5cGVzUG9saWN5ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdHJ1c3RlZFR5cGVzUG9saWN5ID0gX2NyZWF0ZVRydXN0ZWRUeXBlc1BvbGljeSh0cnVzdGVkVHlwZXMsIGN1cnJlbnRTY3JpcHQpO1xuICAgICAgfVxuICAgICAgLy8gSWYgY3JlYXRpbmcgdGhlIGludGVybmFsIHBvbGljeSBzdWNjZWVkZWQgc2lnbiBpbnRlcm5hbCB2YXJpYWJsZXMuXG4gICAgICBpZiAodHJ1c3RlZFR5cGVzUG9saWN5ICE9PSBudWxsICYmIHR5cGVvZiBlbXB0eUhUTUwgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGVtcHR5SFRNTCA9IHRydXN0ZWRUeXBlc1BvbGljeS5jcmVhdGVIVE1MKCcnKTtcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gUHJldmVudCBmdXJ0aGVyIG1hbmlwdWxhdGlvbiBvZiBjb25maWd1cmF0aW9uLlxuICAgIC8vIE5vdCBhdmFpbGFibGUgaW4gSUU4LCBTYWZhcmkgNSwgZXRjLlxuICAgIGlmIChmcmVlemUpIHtcbiAgICAgIGZyZWV6ZShjZmcpO1xuICAgIH1cbiAgICBDT05GSUcgPSBjZmc7XG4gIH07XG4gIC8qIEtlZXAgdHJhY2sgb2YgYWxsIHBvc3NpYmxlIFNWRyBhbmQgTWF0aE1MIHRhZ3NcbiAgICogc28gdGhhdCB3ZSBjYW4gcGVyZm9ybSB0aGUgbmFtZXNwYWNlIGNoZWNrc1xuICAgKiBjb3JyZWN0bHkuICovXG4gIGNvbnN0IEFMTF9TVkdfVEFHUyA9IGFkZFRvU2V0KHt9LCBbLi4uc3ZnJDEsIC4uLnN2Z0ZpbHRlcnMsIC4uLnN2Z0Rpc2FsbG93ZWRdKTtcbiAgY29uc3QgQUxMX01BVEhNTF9UQUdTID0gYWRkVG9TZXQoe30sIFsuLi5tYXRoTWwkMSwgLi4ubWF0aE1sRGlzYWxsb3dlZF0pO1xuICAvKipcbiAgICogQHBhcmFtIGVsZW1lbnQgYSBET00gZWxlbWVudCB3aG9zZSBuYW1lc3BhY2UgaXMgYmVpbmcgY2hlY2tlZFxuICAgKiBAcmV0dXJucyBSZXR1cm4gZmFsc2UgaWYgdGhlIGVsZW1lbnQgaGFzIGFcbiAgICogIG5hbWVzcGFjZSB0aGF0IGEgc3BlYy1jb21wbGlhbnQgcGFyc2VyIHdvdWxkIG5ldmVyXG4gICAqICByZXR1cm4uIFJldHVybiB0cnVlIG90aGVyd2lzZS5cbiAgICovXG4gIGNvbnN0IF9jaGVja1ZhbGlkTmFtZXNwYWNlID0gZnVuY3Rpb24gX2NoZWNrVmFsaWROYW1lc3BhY2UoZWxlbWVudCkge1xuICAgIGxldCBwYXJlbnQgPSBnZXRQYXJlbnROb2RlKGVsZW1lbnQpO1xuICAgIC8vIEluIEpTRE9NLCBpZiB3ZSdyZSBpbnNpZGUgc2hhZG93IERPTSwgdGhlbiBwYXJlbnROb2RlXG4gICAgLy8gY2FuIGJlIG51bGwuIFdlIGp1c3Qgc2ltdWxhdGUgcGFyZW50IGluIHRoaXMgY2FzZS5cbiAgICBpZiAoIXBhcmVudCB8fCAhcGFyZW50LnRhZ05hbWUpIHtcbiAgICAgIHBhcmVudCA9IHtcbiAgICAgICAgbmFtZXNwYWNlVVJJOiBOQU1FU1BBQ0UsXG4gICAgICAgIHRhZ05hbWU6ICd0ZW1wbGF0ZSdcbiAgICAgIH07XG4gICAgfVxuICAgIGNvbnN0IHRhZ05hbWUgPSBzdHJpbmdUb0xvd2VyQ2FzZShlbGVtZW50LnRhZ05hbWUpO1xuICAgIGNvbnN0IHBhcmVudFRhZ05hbWUgPSBzdHJpbmdUb0xvd2VyQ2FzZShwYXJlbnQudGFnTmFtZSk7XG4gICAgaWYgKCFBTExPV0VEX05BTUVTUEFDRVNbZWxlbWVudC5uYW1lc3BhY2VVUkldKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmIChlbGVtZW50Lm5hbWVzcGFjZVVSSSA9PT0gU1ZHX05BTUVTUEFDRSkge1xuICAgICAgLy8gVGhlIG9ubHkgd2F5IHRvIHN3aXRjaCBmcm9tIEhUTUwgbmFtZXNwYWNlIHRvIFNWR1xuICAgICAgLy8gaXMgdmlhIDxzdmc+LiBJZiBpdCBoYXBwZW5zIHZpYSBhbnkgb3RoZXIgdGFnLCB0aGVuXG4gICAgICAvLyBpdCBzaG91bGQgYmUga2lsbGVkLlxuICAgICAgaWYgKHBhcmVudC5uYW1lc3BhY2VVUkkgPT09IEhUTUxfTkFNRVNQQUNFKSB7XG4gICAgICAgIHJldHVybiB0YWdOYW1lID09PSAnc3ZnJztcbiAgICAgIH1cbiAgICAgIC8vIFRoZSBvbmx5IHdheSB0byBzd2l0Y2ggZnJvbSBNYXRoTUwgdG8gU1ZHIGlzIHZpYWBcbiAgICAgIC8vIHN2ZyBpZiBwYXJlbnQgaXMgZWl0aGVyIDxhbm5vdGF0aW9uLXhtbD4gb3IgTWF0aE1MXG4gICAgICAvLyB0ZXh0IGludGVncmF0aW9uIHBvaW50cy5cbiAgICAgIGlmIChwYXJlbnQubmFtZXNwYWNlVVJJID09PSBNQVRITUxfTkFNRVNQQUNFKSB7XG4gICAgICAgIHJldHVybiB0YWdOYW1lID09PSAnc3ZnJyAmJiAocGFyZW50VGFnTmFtZSA9PT0gJ2Fubm90YXRpb24teG1sJyB8fCBNQVRITUxfVEVYVF9JTlRFR1JBVElPTl9QT0lOVFNbcGFyZW50VGFnTmFtZV0pO1xuICAgICAgfVxuICAgICAgLy8gV2Ugb25seSBhbGxvdyBlbGVtZW50cyB0aGF0IGFyZSBkZWZpbmVkIGluIFNWR1xuICAgICAgLy8gc3BlYy4gQWxsIG90aGVycyBhcmUgZGlzYWxsb3dlZCBpbiBTVkcgbmFtZXNwYWNlLlxuICAgICAgcmV0dXJuIEJvb2xlYW4oQUxMX1NWR19UQUdTW3RhZ05hbWVdKTtcbiAgICB9XG4gICAgaWYgKGVsZW1lbnQubmFtZXNwYWNlVVJJID09PSBNQVRITUxfTkFNRVNQQUNFKSB7XG4gICAgICAvLyBUaGUgb25seSB3YXkgdG8gc3dpdGNoIGZyb20gSFRNTCBuYW1lc3BhY2UgdG8gTWF0aE1MXG4gICAgICAvLyBpcyB2aWEgPG1hdGg+LiBJZiBpdCBoYXBwZW5zIHZpYSBhbnkgb3RoZXIgdGFnLCB0aGVuXG4gICAgICAvLyBpdCBzaG91bGQgYmUga2lsbGVkLlxuICAgICAgaWYgKHBhcmVudC5uYW1lc3BhY2VVUkkgPT09IEhUTUxfTkFNRVNQQUNFKSB7XG4gICAgICAgIHJldHVybiB0YWdOYW1lID09PSAnbWF0aCc7XG4gICAgICB9XG4gICAgICAvLyBUaGUgb25seSB3YXkgdG8gc3dpdGNoIGZyb20gU1ZHIHRvIE1hdGhNTCBpcyB2aWFcbiAgICAgIC8vIDxtYXRoPiBhbmQgSFRNTCBpbnRlZ3JhdGlvbiBwb2ludHNcbiAgICAgIGlmIChwYXJlbnQubmFtZXNwYWNlVVJJID09PSBTVkdfTkFNRVNQQUNFKSB7XG4gICAgICAgIHJldHVybiB0YWdOYW1lID09PSAnbWF0aCcgJiYgSFRNTF9JTlRFR1JBVElPTl9QT0lOVFNbcGFyZW50VGFnTmFtZV07XG4gICAgICB9XG4gICAgICAvLyBXZSBvbmx5IGFsbG93IGVsZW1lbnRzIHRoYXQgYXJlIGRlZmluZWQgaW4gTWF0aE1MXG4gICAgICAvLyBzcGVjLiBBbGwgb3RoZXJzIGFyZSBkaXNhbGxvd2VkIGluIE1hdGhNTCBuYW1lc3BhY2UuXG4gICAgICByZXR1cm4gQm9vbGVhbihBTExfTUFUSE1MX1RBR1NbdGFnTmFtZV0pO1xuICAgIH1cbiAgICBpZiAoZWxlbWVudC5uYW1lc3BhY2VVUkkgPT09IEhUTUxfTkFNRVNQQUNFKSB7XG4gICAgICAvLyBUaGUgb25seSB3YXkgdG8gc3dpdGNoIGZyb20gU1ZHIHRvIEhUTUwgaXMgdmlhXG4gICAgICAvLyBIVE1MIGludGVncmF0aW9uIHBvaW50cywgYW5kIGZyb20gTWF0aE1MIHRvIEhUTUxcbiAgICAgIC8vIGlzIHZpYSBNYXRoTUwgdGV4dCBpbnRlZ3JhdGlvbiBwb2ludHNcbiAgICAgIGlmIChwYXJlbnQubmFtZXNwYWNlVVJJID09PSBTVkdfTkFNRVNQQUNFICYmICFIVE1MX0lOVEVHUkFUSU9OX1BPSU5UU1twYXJlbnRUYWdOYW1lXSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBpZiAocGFyZW50Lm5hbWVzcGFjZVVSSSA9PT0gTUFUSE1MX05BTUVTUEFDRSAmJiAhTUFUSE1MX1RFWFRfSU5URUdSQVRJT05fUE9JTlRTW3BhcmVudFRhZ05hbWVdKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIC8vIFdlIGRpc2FsbG93IHRhZ3MgdGhhdCBhcmUgc3BlY2lmaWMgZm9yIE1hdGhNTFxuICAgICAgLy8gb3IgU1ZHIGFuZCBzaG91bGQgbmV2ZXIgYXBwZWFyIGluIEhUTUwgbmFtZXNwYWNlXG4gICAgICByZXR1cm4gIUFMTF9NQVRITUxfVEFHU1t0YWdOYW1lXSAmJiAoQ09NTU9OX1NWR19BTkRfSFRNTF9FTEVNRU5UU1t0YWdOYW1lXSB8fCAhQUxMX1NWR19UQUdTW3RhZ05hbWVdKTtcbiAgICB9XG4gICAgLy8gRm9yIFhIVE1MIGFuZCBYTUwgZG9jdW1lbnRzIHRoYXQgc3VwcG9ydCBjdXN0b20gbmFtZXNwYWNlc1xuICAgIGlmIChQQVJTRVJfTUVESUFfVFlQRSA9PT0gJ2FwcGxpY2F0aW9uL3hodG1sK3htbCcgJiYgQUxMT1dFRF9OQU1FU1BBQ0VTW2VsZW1lbnQubmFtZXNwYWNlVVJJXSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIC8vIFRoZSBjb2RlIHNob3VsZCBuZXZlciByZWFjaCB0aGlzIHBsYWNlICh0aGlzIG1lYW5zXG4gICAgLy8gdGhhdCB0aGUgZWxlbWVudCBzb21laG93IGdvdCBuYW1lc3BhY2UgdGhhdCBpcyBub3RcbiAgICAvLyBIVE1MLCBTVkcsIE1hdGhNTCBvciBhbGxvd2VkIHZpYSBBTExPV0VEX05BTUVTUEFDRVMpLlxuICAgIC8vIFJldHVybiBmYWxzZSBqdXN0IGluIGNhc2UuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9O1xuICAvKipcbiAgICogX2ZvcmNlUmVtb3ZlXG4gICAqXG4gICAqIEBwYXJhbSBub2RlIGEgRE9NIG5vZGVcbiAgICovXG4gIGNvbnN0IF9mb3JjZVJlbW92ZSA9IGZ1bmN0aW9uIF9mb3JjZVJlbW92ZShub2RlKSB7XG4gICAgYXJyYXlQdXNoKERPTVB1cmlmeS5yZW1vdmVkLCB7XG4gICAgICBlbGVtZW50OiBub2RlXG4gICAgfSk7XG4gICAgdHJ5IHtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSB1bmljb3JuL3ByZWZlci1kb20tbm9kZS1yZW1vdmVcbiAgICAgIGdldFBhcmVudE5vZGUobm9kZSkucmVtb3ZlQ2hpbGQobm9kZSk7XG4gICAgfSBjYXRjaCAoXykge1xuICAgICAgcmVtb3ZlKG5vZGUpO1xuICAgIH1cbiAgfTtcbiAgLyoqXG4gICAqIF9yZW1vdmVBdHRyaWJ1dGVcbiAgICpcbiAgICogQHBhcmFtIG5hbWUgYW4gQXR0cmlidXRlIG5hbWVcbiAgICogQHBhcmFtIGVsZW1lbnQgYSBET00gbm9kZVxuICAgKi9cbiAgY29uc3QgX3JlbW92ZUF0dHJpYnV0ZSA9IGZ1bmN0aW9uIF9yZW1vdmVBdHRyaWJ1dGUobmFtZSwgZWxlbWVudCkge1xuICAgIHRyeSB7XG4gICAgICBhcnJheVB1c2goRE9NUHVyaWZ5LnJlbW92ZWQsIHtcbiAgICAgICAgYXR0cmlidXRlOiBlbGVtZW50LmdldEF0dHJpYnV0ZU5vZGUobmFtZSksXG4gICAgICAgIGZyb206IGVsZW1lbnRcbiAgICAgIH0pO1xuICAgIH0gY2F0Y2ggKF8pIHtcbiAgICAgIGFycmF5UHVzaChET01QdXJpZnkucmVtb3ZlZCwge1xuICAgICAgICBhdHRyaWJ1dGU6IG51bGwsXG4gICAgICAgIGZyb206IGVsZW1lbnRcbiAgICAgIH0pO1xuICAgIH1cbiAgICBlbGVtZW50LnJlbW92ZUF0dHJpYnV0ZShuYW1lKTtcbiAgICAvLyBXZSB2b2lkIGF0dHJpYnV0ZSB2YWx1ZXMgZm9yIHVucmVtb3ZhYmxlIFwiaXNcIiBhdHRyaWJ1dGVzXG4gICAgaWYgKG5hbWUgPT09ICdpcycpIHtcbiAgICAgIGlmIChSRVRVUk5fRE9NIHx8IFJFVFVSTl9ET01fRlJBR01FTlQpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBfZm9yY2VSZW1vdmUoZWxlbWVudCk7XG4gICAgICAgIH0gY2F0Y2ggKF8pIHt9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKG5hbWUsICcnKTtcbiAgICAgICAgfSBjYXRjaCAoXykge31cbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIC8qKlxuICAgKiBfaW5pdERvY3VtZW50XG4gICAqXG4gICAqIEBwYXJhbSBkaXJ0eSAtIGEgc3RyaW5nIG9mIGRpcnR5IG1hcmt1cFxuICAgKiBAcmV0dXJuIGEgRE9NLCBmaWxsZWQgd2l0aCB0aGUgZGlydHkgbWFya3VwXG4gICAqL1xuICBjb25zdCBfaW5pdERvY3VtZW50ID0gZnVuY3Rpb24gX2luaXREb2N1bWVudChkaXJ0eSkge1xuICAgIC8qIENyZWF0ZSBhIEhUTUwgZG9jdW1lbnQgKi9cbiAgICBsZXQgZG9jID0gbnVsbDtcbiAgICBsZXQgbGVhZGluZ1doaXRlc3BhY2UgPSBudWxsO1xuICAgIGlmIChGT1JDRV9CT0RZKSB7XG4gICAgICBkaXJ0eSA9ICc8cmVtb3ZlPjwvcmVtb3ZlPicgKyBkaXJ0eTtcbiAgICB9IGVsc2Uge1xuICAgICAgLyogSWYgRk9SQ0VfQk9EWSBpc24ndCB1c2VkLCBsZWFkaW5nIHdoaXRlc3BhY2UgbmVlZHMgdG8gYmUgcHJlc2VydmVkIG1hbnVhbGx5ICovXG4gICAgICBjb25zdCBtYXRjaGVzID0gc3RyaW5nTWF0Y2goZGlydHksIC9eW1xcclxcblxcdCBdKy8pO1xuICAgICAgbGVhZGluZ1doaXRlc3BhY2UgPSBtYXRjaGVzICYmIG1hdGNoZXNbMF07XG4gICAgfVxuICAgIGlmIChQQVJTRVJfTUVESUFfVFlQRSA9PT0gJ2FwcGxpY2F0aW9uL3hodG1sK3htbCcgJiYgTkFNRVNQQUNFID09PSBIVE1MX05BTUVTUEFDRSkge1xuICAgICAgLy8gUm9vdCBvZiBYSFRNTCBkb2MgbXVzdCBjb250YWluIHhtbG5zIGRlY2xhcmF0aW9uIChzZWUgaHR0cHM6Ly93d3cudzMub3JnL1RSL3hodG1sMS9ub3JtYXRpdmUuaHRtbCNzdHJpY3QpXG4gICAgICBkaXJ0eSA9ICc8aHRtbCB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzE5OTkveGh0bWxcIj48aGVhZD48L2hlYWQ+PGJvZHk+JyArIGRpcnR5ICsgJzwvYm9keT48L2h0bWw+JztcbiAgICB9XG4gICAgY29uc3QgZGlydHlQYXlsb2FkID0gdHJ1c3RlZFR5cGVzUG9saWN5ID8gdHJ1c3RlZFR5cGVzUG9saWN5LmNyZWF0ZUhUTUwoZGlydHkpIDogZGlydHk7XG4gICAgLypcbiAgICAgKiBVc2UgdGhlIERPTVBhcnNlciBBUEkgYnkgZGVmYXVsdCwgZmFsbGJhY2sgbGF0ZXIgaWYgbmVlZHMgYmVcbiAgICAgKiBET01QYXJzZXIgbm90IHdvcmsgZm9yIHN2ZyB3aGVuIGhhcyBtdWx0aXBsZSByb290IGVsZW1lbnQuXG4gICAgICovXG4gICAgaWYgKE5BTUVTUEFDRSA9PT0gSFRNTF9OQU1FU1BBQ0UpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGRvYyA9IG5ldyBET01QYXJzZXIoKS5wYXJzZUZyb21TdHJpbmcoZGlydHlQYXlsb2FkLCBQQVJTRVJfTUVESUFfVFlQRSk7XG4gICAgICB9IGNhdGNoIChfKSB7fVxuICAgIH1cbiAgICAvKiBVc2UgY3JlYXRlSFRNTERvY3VtZW50IGluIGNhc2UgRE9NUGFyc2VyIGlzIG5vdCBhdmFpbGFibGUgKi9cbiAgICBpZiAoIWRvYyB8fCAhZG9jLmRvY3VtZW50RWxlbWVudCkge1xuICAgICAgZG9jID0gaW1wbGVtZW50YXRpb24uY3JlYXRlRG9jdW1lbnQoTkFNRVNQQUNFLCAndGVtcGxhdGUnLCBudWxsKTtcbiAgICAgIHRyeSB7XG4gICAgICAgIGRvYy5kb2N1bWVudEVsZW1lbnQuaW5uZXJIVE1MID0gSVNfRU1QVFlfSU5QVVQgPyBlbXB0eUhUTUwgOiBkaXJ0eVBheWxvYWQ7XG4gICAgICB9IGNhdGNoIChfKSB7XG4gICAgICAgIC8vIFN5bnRheCBlcnJvciBpZiBkaXJ0eVBheWxvYWQgaXMgaW52YWxpZCB4bWxcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgYm9keSA9IGRvYy5ib2R5IHx8IGRvYy5kb2N1bWVudEVsZW1lbnQ7XG4gICAgaWYgKGRpcnR5ICYmIGxlYWRpbmdXaGl0ZXNwYWNlKSB7XG4gICAgICBib2R5Lmluc2VydEJlZm9yZShkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShsZWFkaW5nV2hpdGVzcGFjZSksIGJvZHkuY2hpbGROb2Rlc1swXSB8fCBudWxsKTtcbiAgICB9XG4gICAgLyogV29yayBvbiB3aG9sZSBkb2N1bWVudCBvciBqdXN0IGl0cyBib2R5ICovXG4gICAgaWYgKE5BTUVTUEFDRSA9PT0gSFRNTF9OQU1FU1BBQ0UpIHtcbiAgICAgIHJldHVybiBnZXRFbGVtZW50c0J5VGFnTmFtZS5jYWxsKGRvYywgV0hPTEVfRE9DVU1FTlQgPyAnaHRtbCcgOiAnYm9keScpWzBdO1xuICAgIH1cbiAgICByZXR1cm4gV0hPTEVfRE9DVU1FTlQgPyBkb2MuZG9jdW1lbnRFbGVtZW50IDogYm9keTtcbiAgfTtcbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBOb2RlSXRlcmF0b3Igb2JqZWN0IHRoYXQgeW91IGNhbiB1c2UgdG8gdHJhdmVyc2UgZmlsdGVyZWQgbGlzdHMgb2Ygbm9kZXMgb3IgZWxlbWVudHMgaW4gYSBkb2N1bWVudC5cbiAgICpcbiAgICogQHBhcmFtIHJvb3QgVGhlIHJvb3QgZWxlbWVudCBvciBub2RlIHRvIHN0YXJ0IHRyYXZlcnNpbmcgb24uXG4gICAqIEByZXR1cm4gVGhlIGNyZWF0ZWQgTm9kZUl0ZXJhdG9yXG4gICAqL1xuICBjb25zdCBfY3JlYXRlTm9kZUl0ZXJhdG9yID0gZnVuY3Rpb24gX2NyZWF0ZU5vZGVJdGVyYXRvcihyb290KSB7XG4gICAgcmV0dXJuIGNyZWF0ZU5vZGVJdGVyYXRvci5jYWxsKHJvb3Qub3duZXJEb2N1bWVudCB8fCByb290LCByb290LFxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1iaXR3aXNlXG4gICAgTm9kZUZpbHRlci5TSE9XX0VMRU1FTlQgfCBOb2RlRmlsdGVyLlNIT1dfQ09NTUVOVCB8IE5vZGVGaWx0ZXIuU0hPV19URVhUIHwgTm9kZUZpbHRlci5TSE9XX1BST0NFU1NJTkdfSU5TVFJVQ1RJT04gfCBOb2RlRmlsdGVyLlNIT1dfQ0RBVEFfU0VDVElPTiwgbnVsbCk7XG4gIH07XG4gIC8qKlxuICAgKiBfaXNDbG9iYmVyZWRcbiAgICpcbiAgICogQHBhcmFtIGVsZW1lbnQgZWxlbWVudCB0byBjaGVjayBmb3IgY2xvYmJlcmluZyBhdHRhY2tzXG4gICAqIEByZXR1cm4gdHJ1ZSBpZiBjbG9iYmVyZWQsIGZhbHNlIGlmIHNhZmVcbiAgICovXG4gIGNvbnN0IF9pc0Nsb2JiZXJlZCA9IGZ1bmN0aW9uIF9pc0Nsb2JiZXJlZChlbGVtZW50KSB7XG4gICAgcmV0dXJuIGVsZW1lbnQgaW5zdGFuY2VvZiBIVE1MRm9ybUVsZW1lbnQgJiYgKHR5cGVvZiBlbGVtZW50Lm5vZGVOYW1lICE9PSAnc3RyaW5nJyB8fCB0eXBlb2YgZWxlbWVudC50ZXh0Q29udGVudCAhPT0gJ3N0cmluZycgfHwgdHlwZW9mIGVsZW1lbnQucmVtb3ZlQ2hpbGQgIT09ICdmdW5jdGlvbicgfHwgIShlbGVtZW50LmF0dHJpYnV0ZXMgaW5zdGFuY2VvZiBOYW1lZE5vZGVNYXApIHx8IHR5cGVvZiBlbGVtZW50LnJlbW92ZUF0dHJpYnV0ZSAhPT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2YgZWxlbWVudC5zZXRBdHRyaWJ1dGUgIT09ICdmdW5jdGlvbicgfHwgdHlwZW9mIGVsZW1lbnQubmFtZXNwYWNlVVJJICE9PSAnc3RyaW5nJyB8fCB0eXBlb2YgZWxlbWVudC5pbnNlcnRCZWZvcmUgIT09ICdmdW5jdGlvbicgfHwgdHlwZW9mIGVsZW1lbnQuaGFzQ2hpbGROb2RlcyAhPT0gJ2Z1bmN0aW9uJyk7XG4gIH07XG4gIC8qKlxuICAgKiBDaGVja3Mgd2hldGhlciB0aGUgZ2l2ZW4gb2JqZWN0IGlzIGEgRE9NIG5vZGUuXG4gICAqXG4gICAqIEBwYXJhbSB2YWx1ZSBvYmplY3QgdG8gY2hlY2sgd2hldGhlciBpdCdzIGEgRE9NIG5vZGVcbiAgICogQHJldHVybiB0cnVlIGlzIG9iamVjdCBpcyBhIERPTSBub2RlXG4gICAqL1xuICBjb25zdCBfaXNOb2RlID0gZnVuY3Rpb24gX2lzTm9kZSh2YWx1ZSkge1xuICAgIHJldHVybiB0eXBlb2YgTm9kZSA9PT0gJ2Z1bmN0aW9uJyAmJiB2YWx1ZSBpbnN0YW5jZW9mIE5vZGU7XG4gIH07XG4gIGZ1bmN0aW9uIF9leGVjdXRlSG9va3MoaG9va3MsIGN1cnJlbnROb2RlLCBkYXRhKSB7XG4gICAgYXJyYXlGb3JFYWNoKGhvb2tzLCBob29rID0+IHtcbiAgICAgIGhvb2suY2FsbChET01QdXJpZnksIGN1cnJlbnROb2RlLCBkYXRhLCBDT05GSUcpO1xuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBfc2FuaXRpemVFbGVtZW50c1xuICAgKlxuICAgKiBAcHJvdGVjdCBub2RlTmFtZVxuICAgKiBAcHJvdGVjdCB0ZXh0Q29udGVudFxuICAgKiBAcHJvdGVjdCByZW1vdmVDaGlsZFxuICAgKiBAcGFyYW0gY3VycmVudE5vZGUgdG8gY2hlY2sgZm9yIHBlcm1pc3Npb24gdG8gZXhpc3RcbiAgICogQHJldHVybiB0cnVlIGlmIG5vZGUgd2FzIGtpbGxlZCwgZmFsc2UgaWYgbGVmdCBhbGl2ZVxuICAgKi9cbiAgY29uc3QgX3Nhbml0aXplRWxlbWVudHMgPSBmdW5jdGlvbiBfc2FuaXRpemVFbGVtZW50cyhjdXJyZW50Tm9kZSkge1xuICAgIGxldCBjb250ZW50ID0gbnVsbDtcbiAgICAvKiBFeGVjdXRlIGEgaG9vayBpZiBwcmVzZW50ICovXG4gICAgX2V4ZWN1dGVIb29rcyhob29rcy5iZWZvcmVTYW5pdGl6ZUVsZW1lbnRzLCBjdXJyZW50Tm9kZSwgbnVsbCk7XG4gICAgLyogQ2hlY2sgaWYgZWxlbWVudCBpcyBjbG9iYmVyZWQgb3IgY2FuIGNsb2JiZXIgKi9cbiAgICBpZiAoX2lzQ2xvYmJlcmVkKGN1cnJlbnROb2RlKSkge1xuICAgICAgX2ZvcmNlUmVtb3ZlKGN1cnJlbnROb2RlKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICAvKiBOb3cgbGV0J3MgY2hlY2sgdGhlIGVsZW1lbnQncyB0eXBlIGFuZCBuYW1lICovXG4gICAgY29uc3QgdGFnTmFtZSA9IHRyYW5zZm9ybUNhc2VGdW5jKGN1cnJlbnROb2RlLm5vZGVOYW1lKTtcbiAgICAvKiBFeGVjdXRlIGEgaG9vayBpZiBwcmVzZW50ICovXG4gICAgX2V4ZWN1dGVIb29rcyhob29rcy51cG9uU2FuaXRpemVFbGVtZW50LCBjdXJyZW50Tm9kZSwge1xuICAgICAgdGFnTmFtZSxcbiAgICAgIGFsbG93ZWRUYWdzOiBBTExPV0VEX1RBR1NcbiAgICB9KTtcbiAgICAvKiBEZXRlY3QgbVhTUyBhdHRlbXB0cyBhYnVzaW5nIG5hbWVzcGFjZSBjb25mdXNpb24gKi9cbiAgICBpZiAoY3VycmVudE5vZGUuaGFzQ2hpbGROb2RlcygpICYmICFfaXNOb2RlKGN1cnJlbnROb2RlLmZpcnN0RWxlbWVudENoaWxkKSAmJiByZWdFeHBUZXN0KC88Wy9cXHddL2csIGN1cnJlbnROb2RlLmlubmVySFRNTCkgJiYgcmVnRXhwVGVzdCgvPFsvXFx3XS9nLCBjdXJyZW50Tm9kZS50ZXh0Q29udGVudCkpIHtcbiAgICAgIF9mb3JjZVJlbW92ZShjdXJyZW50Tm9kZSk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgLyogUmVtb3ZlIGFueSBvY2N1cnJlbmNlIG9mIHByb2Nlc3NpbmcgaW5zdHJ1Y3Rpb25zICovXG4gICAgaWYgKGN1cnJlbnROb2RlLm5vZGVUeXBlID09PSBOT0RFX1RZUEUucHJvZ3Jlc3NpbmdJbnN0cnVjdGlvbikge1xuICAgICAgX2ZvcmNlUmVtb3ZlKGN1cnJlbnROb2RlKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICAvKiBSZW1vdmUgYW55IGtpbmQgb2YgcG9zc2libHkgaGFybWZ1bCBjb21tZW50cyAqL1xuICAgIGlmIChTQUZFX0ZPUl9YTUwgJiYgY3VycmVudE5vZGUubm9kZVR5cGUgPT09IE5PREVfVFlQRS5jb21tZW50ICYmIHJlZ0V4cFRlc3QoLzxbL1xcd10vZywgY3VycmVudE5vZGUuZGF0YSkpIHtcbiAgICAgIF9mb3JjZVJlbW92ZShjdXJyZW50Tm9kZSk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgLyogUmVtb3ZlIGVsZW1lbnQgaWYgYW55dGhpbmcgZm9yYmlkcyBpdHMgcHJlc2VuY2UgKi9cbiAgICBpZiAoIUFMTE9XRURfVEFHU1t0YWdOYW1lXSB8fCBGT1JCSURfVEFHU1t0YWdOYW1lXSkge1xuICAgICAgLyogQ2hlY2sgaWYgd2UgaGF2ZSBhIGN1c3RvbSBlbGVtZW50IHRvIGhhbmRsZSAqL1xuICAgICAgaWYgKCFGT1JCSURfVEFHU1t0YWdOYW1lXSAmJiBfaXNCYXNpY0N1c3RvbUVsZW1lbnQodGFnTmFtZSkpIHtcbiAgICAgICAgaWYgKENVU1RPTV9FTEVNRU5UX0hBTkRMSU5HLnRhZ05hbWVDaGVjayBpbnN0YW5jZW9mIFJlZ0V4cCAmJiByZWdFeHBUZXN0KENVU1RPTV9FTEVNRU5UX0hBTkRMSU5HLnRhZ05hbWVDaGVjaywgdGFnTmFtZSkpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKENVU1RPTV9FTEVNRU5UX0hBTkRMSU5HLnRhZ05hbWVDaGVjayBpbnN0YW5jZW9mIEZ1bmN0aW9uICYmIENVU1RPTV9FTEVNRU5UX0hBTkRMSU5HLnRhZ05hbWVDaGVjayh0YWdOYW1lKSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLyogS2VlcCBjb250ZW50IGV4Y2VwdCBmb3IgYmFkLWxpc3RlZCBlbGVtZW50cyAqL1xuICAgICAgaWYgKEtFRVBfQ09OVEVOVCAmJiAhRk9SQklEX0NPTlRFTlRTW3RhZ05hbWVdKSB7XG4gICAgICAgIGNvbnN0IHBhcmVudE5vZGUgPSBnZXRQYXJlbnROb2RlKGN1cnJlbnROb2RlKSB8fCBjdXJyZW50Tm9kZS5wYXJlbnROb2RlO1xuICAgICAgICBjb25zdCBjaGlsZE5vZGVzID0gZ2V0Q2hpbGROb2RlcyhjdXJyZW50Tm9kZSkgfHwgY3VycmVudE5vZGUuY2hpbGROb2RlcztcbiAgICAgICAgaWYgKGNoaWxkTm9kZXMgJiYgcGFyZW50Tm9kZSkge1xuICAgICAgICAgIGNvbnN0IGNoaWxkQ291bnQgPSBjaGlsZE5vZGVzLmxlbmd0aDtcbiAgICAgICAgICBmb3IgKGxldCBpID0gY2hpbGRDb3VudCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgICAgICBjb25zdCBjaGlsZENsb25lID0gY2xvbmVOb2RlKGNoaWxkTm9kZXNbaV0sIHRydWUpO1xuICAgICAgICAgICAgY2hpbGRDbG9uZS5fX3JlbW92YWxDb3VudCA9IChjdXJyZW50Tm9kZS5fX3JlbW92YWxDb3VudCB8fCAwKSArIDE7XG4gICAgICAgICAgICBwYXJlbnROb2RlLmluc2VydEJlZm9yZShjaGlsZENsb25lLCBnZXROZXh0U2libGluZyhjdXJyZW50Tm9kZSkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgX2ZvcmNlUmVtb3ZlKGN1cnJlbnROb2RlKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICAvKiBDaGVjayB3aGV0aGVyIGVsZW1lbnQgaGFzIGEgdmFsaWQgbmFtZXNwYWNlICovXG4gICAgaWYgKGN1cnJlbnROb2RlIGluc3RhbmNlb2YgRWxlbWVudCAmJiAhX2NoZWNrVmFsaWROYW1lc3BhY2UoY3VycmVudE5vZGUpKSB7XG4gICAgICBfZm9yY2VSZW1vdmUoY3VycmVudE5vZGUpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIC8qIE1ha2Ugc3VyZSB0aGF0IG9sZGVyIGJyb3dzZXJzIGRvbid0IGdldCBmYWxsYmFjay10YWcgbVhTUyAqL1xuICAgIGlmICgodGFnTmFtZSA9PT0gJ25vc2NyaXB0JyB8fCB0YWdOYW1lID09PSAnbm9lbWJlZCcgfHwgdGFnTmFtZSA9PT0gJ25vZnJhbWVzJykgJiYgcmVnRXhwVGVzdCgvPFxcL25vKHNjcmlwdHxlbWJlZHxmcmFtZXMpL2ksIGN1cnJlbnROb2RlLmlubmVySFRNTCkpIHtcbiAgICAgIF9mb3JjZVJlbW92ZShjdXJyZW50Tm9kZSk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgLyogU2FuaXRpemUgZWxlbWVudCBjb250ZW50IHRvIGJlIHRlbXBsYXRlLXNhZmUgKi9cbiAgICBpZiAoU0FGRV9GT1JfVEVNUExBVEVTICYmIGN1cnJlbnROb2RlLm5vZGVUeXBlID09PSBOT0RFX1RZUEUudGV4dCkge1xuICAgICAgLyogR2V0IHRoZSBlbGVtZW50J3MgdGV4dCBjb250ZW50ICovXG4gICAgICBjb250ZW50ID0gY3VycmVudE5vZGUudGV4dENvbnRlbnQ7XG4gICAgICBhcnJheUZvckVhY2goW01VU1RBQ0hFX0VYUFIsIEVSQl9FWFBSLCBUTVBMSVRfRVhQUl0sIGV4cHIgPT4ge1xuICAgICAgICBjb250ZW50ID0gc3RyaW5nUmVwbGFjZShjb250ZW50LCBleHByLCAnICcpO1xuICAgICAgfSk7XG4gICAgICBpZiAoY3VycmVudE5vZGUudGV4dENvbnRlbnQgIT09IGNvbnRlbnQpIHtcbiAgICAgICAgYXJyYXlQdXNoKERPTVB1cmlmeS5yZW1vdmVkLCB7XG4gICAgICAgICAgZWxlbWVudDogY3VycmVudE5vZGUuY2xvbmVOb2RlKClcbiAgICAgICAgfSk7XG4gICAgICAgIGN1cnJlbnROb2RlLnRleHRDb250ZW50ID0gY29udGVudDtcbiAgICAgIH1cbiAgICB9XG4gICAgLyogRXhlY3V0ZSBhIGhvb2sgaWYgcHJlc2VudCAqL1xuICAgIF9leGVjdXRlSG9va3MoaG9va3MuYWZ0ZXJTYW5pdGl6ZUVsZW1lbnRzLCBjdXJyZW50Tm9kZSwgbnVsbCk7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9O1xuICAvKipcbiAgICogX2lzVmFsaWRBdHRyaWJ1dGVcbiAgICpcbiAgICogQHBhcmFtIGxjVGFnIExvd2VyY2FzZSB0YWcgbmFtZSBvZiBjb250YWluaW5nIGVsZW1lbnQuXG4gICAqIEBwYXJhbSBsY05hbWUgTG93ZXJjYXNlIGF0dHJpYnV0ZSBuYW1lLlxuICAgKiBAcGFyYW0gdmFsdWUgQXR0cmlidXRlIHZhbHVlLlxuICAgKiBAcmV0dXJuIFJldHVybnMgdHJ1ZSBpZiBgdmFsdWVgIGlzIHZhbGlkLCBvdGhlcndpc2UgZmFsc2UuXG4gICAqL1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgY29tcGxleGl0eVxuICBjb25zdCBfaXNWYWxpZEF0dHJpYnV0ZSA9IGZ1bmN0aW9uIF9pc1ZhbGlkQXR0cmlidXRlKGxjVGFnLCBsY05hbWUsIHZhbHVlKSB7XG4gICAgLyogTWFrZSBzdXJlIGF0dHJpYnV0ZSBjYW5ub3QgY2xvYmJlciAqL1xuICAgIGlmIChTQU5JVElaRV9ET00gJiYgKGxjTmFtZSA9PT0gJ2lkJyB8fCBsY05hbWUgPT09ICduYW1lJykgJiYgKHZhbHVlIGluIGRvY3VtZW50IHx8IHZhbHVlIGluIGZvcm1FbGVtZW50KSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICAvKiBBbGxvdyB2YWxpZCBkYXRhLSogYXR0cmlidXRlczogQXQgbGVhc3Qgb25lIGNoYXJhY3RlciBhZnRlciBcIi1cIlxuICAgICAgICAoaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2UvZG9tLmh0bWwjZW1iZWRkaW5nLWN1c3RvbS1ub24tdmlzaWJsZS1kYXRhLXdpdGgtdGhlLWRhdGEtKi1hdHRyaWJ1dGVzKVxuICAgICAgICBYTUwtY29tcGF0aWJsZSAoaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2UvaW5mcmFzdHJ1Y3R1cmUuaHRtbCN4bWwtY29tcGF0aWJsZSBhbmQgaHR0cDovL3d3dy53My5vcmcvVFIveG1sLyNkMGU4MDQpXG4gICAgICAgIFdlIGRvbid0IG5lZWQgdG8gY2hlY2sgdGhlIHZhbHVlOyBpdCdzIGFsd2F5cyBVUkkgc2FmZS4gKi9cbiAgICBpZiAoQUxMT1dfREFUQV9BVFRSICYmICFGT1JCSURfQVRUUltsY05hbWVdICYmIHJlZ0V4cFRlc3QoREFUQV9BVFRSLCBsY05hbWUpKSA7IGVsc2UgaWYgKEFMTE9XX0FSSUFfQVRUUiAmJiByZWdFeHBUZXN0KEFSSUFfQVRUUiwgbGNOYW1lKSkgOyBlbHNlIGlmICghQUxMT1dFRF9BVFRSW2xjTmFtZV0gfHwgRk9SQklEX0FUVFJbbGNOYW1lXSkge1xuICAgICAgaWYgKFxuICAgICAgLy8gRmlyc3QgY29uZGl0aW9uIGRvZXMgYSB2ZXJ5IGJhc2ljIGNoZWNrIGlmIGEpIGl0J3MgYmFzaWNhbGx5IGEgdmFsaWQgY3VzdG9tIGVsZW1lbnQgdGFnbmFtZSBBTkRcbiAgICAgIC8vIGIpIGlmIHRoZSB0YWdOYW1lIHBhc3NlcyB3aGF0ZXZlciB0aGUgdXNlciBoYXMgY29uZmlndXJlZCBmb3IgQ1VTVE9NX0VMRU1FTlRfSEFORExJTkcudGFnTmFtZUNoZWNrXG4gICAgICAvLyBhbmQgYykgaWYgdGhlIGF0dHJpYnV0ZSBuYW1lIHBhc3NlcyB3aGF0ZXZlciB0aGUgdXNlciBoYXMgY29uZmlndXJlZCBmb3IgQ1VTVE9NX0VMRU1FTlRfSEFORExJTkcuYXR0cmlidXRlTmFtZUNoZWNrXG4gICAgICBfaXNCYXNpY0N1c3RvbUVsZW1lbnQobGNUYWcpICYmIChDVVNUT01fRUxFTUVOVF9IQU5ETElORy50YWdOYW1lQ2hlY2sgaW5zdGFuY2VvZiBSZWdFeHAgJiYgcmVnRXhwVGVzdChDVVNUT01fRUxFTUVOVF9IQU5ETElORy50YWdOYW1lQ2hlY2ssIGxjVGFnKSB8fCBDVVNUT01fRUxFTUVOVF9IQU5ETElORy50YWdOYW1lQ2hlY2sgaW5zdGFuY2VvZiBGdW5jdGlvbiAmJiBDVVNUT01fRUxFTUVOVF9IQU5ETElORy50YWdOYW1lQ2hlY2sobGNUYWcpKSAmJiAoQ1VTVE9NX0VMRU1FTlRfSEFORExJTkcuYXR0cmlidXRlTmFtZUNoZWNrIGluc3RhbmNlb2YgUmVnRXhwICYmIHJlZ0V4cFRlc3QoQ1VTVE9NX0VMRU1FTlRfSEFORExJTkcuYXR0cmlidXRlTmFtZUNoZWNrLCBsY05hbWUpIHx8IENVU1RPTV9FTEVNRU5UX0hBTkRMSU5HLmF0dHJpYnV0ZU5hbWVDaGVjayBpbnN0YW5jZW9mIEZ1bmN0aW9uICYmIENVU1RPTV9FTEVNRU5UX0hBTkRMSU5HLmF0dHJpYnV0ZU5hbWVDaGVjayhsY05hbWUpKSB8fFxuICAgICAgLy8gQWx0ZXJuYXRpdmUsIHNlY29uZCBjb25kaXRpb24gY2hlY2tzIGlmIGl0J3MgYW4gYGlzYC1hdHRyaWJ1dGUsIEFORFxuICAgICAgLy8gdGhlIHZhbHVlIHBhc3NlcyB3aGF0ZXZlciB0aGUgdXNlciBoYXMgY29uZmlndXJlZCBmb3IgQ1VTVE9NX0VMRU1FTlRfSEFORExJTkcudGFnTmFtZUNoZWNrXG4gICAgICBsY05hbWUgPT09ICdpcycgJiYgQ1VTVE9NX0VMRU1FTlRfSEFORExJTkcuYWxsb3dDdXN0b21pemVkQnVpbHRJbkVsZW1lbnRzICYmIChDVVNUT01fRUxFTUVOVF9IQU5ETElORy50YWdOYW1lQ2hlY2sgaW5zdGFuY2VvZiBSZWdFeHAgJiYgcmVnRXhwVGVzdChDVVNUT01fRUxFTUVOVF9IQU5ETElORy50YWdOYW1lQ2hlY2ssIHZhbHVlKSB8fCBDVVNUT01fRUxFTUVOVF9IQU5ETElORy50YWdOYW1lQ2hlY2sgaW5zdGFuY2VvZiBGdW5jdGlvbiAmJiBDVVNUT01fRUxFTUVOVF9IQU5ETElORy50YWdOYW1lQ2hlY2sodmFsdWUpKSkgOyBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgLyogQ2hlY2sgdmFsdWUgaXMgc2FmZS4gRmlyc3QsIGlzIGF0dHIgaW5lcnQ/IElmIHNvLCBpcyBzYWZlICovXG4gICAgfSBlbHNlIGlmIChVUklfU0FGRV9BVFRSSUJVVEVTW2xjTmFtZV0pIDsgZWxzZSBpZiAocmVnRXhwVGVzdChJU19BTExPV0VEX1VSSSQxLCBzdHJpbmdSZXBsYWNlKHZhbHVlLCBBVFRSX1dISVRFU1BBQ0UsICcnKSkpIDsgZWxzZSBpZiAoKGxjTmFtZSA9PT0gJ3NyYycgfHwgbGNOYW1lID09PSAneGxpbms6aHJlZicgfHwgbGNOYW1lID09PSAnaHJlZicpICYmIGxjVGFnICE9PSAnc2NyaXB0JyAmJiBzdHJpbmdJbmRleE9mKHZhbHVlLCAnZGF0YTonKSA9PT0gMCAmJiBEQVRBX1VSSV9UQUdTW2xjVGFnXSkgOyBlbHNlIGlmIChBTExPV19VTktOT1dOX1BST1RPQ09MUyAmJiAhcmVnRXhwVGVzdChJU19TQ1JJUFRfT1JfREFUQSwgc3RyaW5nUmVwbGFjZSh2YWx1ZSwgQVRUUl9XSElURVNQQUNFLCAnJykpKSA7IGVsc2UgaWYgKHZhbHVlKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSBlbHNlIDtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfTtcbiAgLyoqXG4gICAqIF9pc0Jhc2ljQ3VzdG9tRWxlbWVudFxuICAgKiBjaGVja3MgaWYgYXQgbGVhc3Qgb25lIGRhc2ggaXMgaW5jbHVkZWQgaW4gdGFnTmFtZSwgYW5kIGl0J3Mgbm90IHRoZSBmaXJzdCBjaGFyXG4gICAqIGZvciBtb3JlIHNvcGhpc3RpY2F0ZWQgY2hlY2tpbmcgc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9zaW5kcmVzb3JodXMvdmFsaWRhdGUtZWxlbWVudC1uYW1lXG4gICAqXG4gICAqIEBwYXJhbSB0YWdOYW1lIG5hbWUgb2YgdGhlIHRhZyBvZiB0aGUgbm9kZSB0byBzYW5pdGl6ZVxuICAgKiBAcmV0dXJucyBSZXR1cm5zIHRydWUgaWYgdGhlIHRhZyBuYW1lIG1lZXRzIHRoZSBiYXNpYyBjcml0ZXJpYSBmb3IgYSBjdXN0b20gZWxlbWVudCwgb3RoZXJ3aXNlIGZhbHNlLlxuICAgKi9cbiAgY29uc3QgX2lzQmFzaWNDdXN0b21FbGVtZW50ID0gZnVuY3Rpb24gX2lzQmFzaWNDdXN0b21FbGVtZW50KHRhZ05hbWUpIHtcbiAgICByZXR1cm4gdGFnTmFtZSAhPT0gJ2Fubm90YXRpb24teG1sJyAmJiBzdHJpbmdNYXRjaCh0YWdOYW1lLCBDVVNUT01fRUxFTUVOVCk7XG4gIH07XG4gIC8qKlxuICAgKiBfc2FuaXRpemVBdHRyaWJ1dGVzXG4gICAqXG4gICAqIEBwcm90ZWN0IGF0dHJpYnV0ZXNcbiAgICogQHByb3RlY3Qgbm9kZU5hbWVcbiAgICogQHByb3RlY3QgcmVtb3ZlQXR0cmlidXRlXG4gICAqIEBwcm90ZWN0IHNldEF0dHJpYnV0ZVxuICAgKlxuICAgKiBAcGFyYW0gY3VycmVudE5vZGUgdG8gc2FuaXRpemVcbiAgICovXG4gIGNvbnN0IF9zYW5pdGl6ZUF0dHJpYnV0ZXMgPSBmdW5jdGlvbiBfc2FuaXRpemVBdHRyaWJ1dGVzKGN1cnJlbnROb2RlKSB7XG4gICAgLyogRXhlY3V0ZSBhIGhvb2sgaWYgcHJlc2VudCAqL1xuICAgIF9leGVjdXRlSG9va3MoaG9va3MuYmVmb3JlU2FuaXRpemVBdHRyaWJ1dGVzLCBjdXJyZW50Tm9kZSwgbnVsbCk7XG4gICAgY29uc3Qge1xuICAgICAgYXR0cmlidXRlc1xuICAgIH0gPSBjdXJyZW50Tm9kZTtcbiAgICAvKiBDaGVjayBpZiB3ZSBoYXZlIGF0dHJpYnV0ZXM7IGlmIG5vdCB3ZSBtaWdodCBoYXZlIGEgdGV4dCBub2RlICovXG4gICAgaWYgKCFhdHRyaWJ1dGVzIHx8IF9pc0Nsb2JiZXJlZChjdXJyZW50Tm9kZSkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgaG9va0V2ZW50ID0ge1xuICAgICAgYXR0ck5hbWU6ICcnLFxuICAgICAgYXR0clZhbHVlOiAnJyxcbiAgICAgIGtlZXBBdHRyOiB0cnVlLFxuICAgICAgYWxsb3dlZEF0dHJpYnV0ZXM6IEFMTE9XRURfQVRUUixcbiAgICAgIGZvcmNlS2VlcEF0dHI6IHVuZGVmaW5lZFxuICAgIH07XG4gICAgbGV0IGwgPSBhdHRyaWJ1dGVzLmxlbmd0aDtcbiAgICAvKiBHbyBiYWNrd2FyZHMgb3ZlciBhbGwgYXR0cmlidXRlczsgc2FmZWx5IHJlbW92ZSBiYWQgb25lcyAqL1xuICAgIHdoaWxlIChsLS0pIHtcbiAgICAgIGNvbnN0IGF0dHIgPSBhdHRyaWJ1dGVzW2xdO1xuICAgICAgY29uc3Qge1xuICAgICAgICBuYW1lLFxuICAgICAgICBuYW1lc3BhY2VVUkksXG4gICAgICAgIHZhbHVlOiBhdHRyVmFsdWVcbiAgICAgIH0gPSBhdHRyO1xuICAgICAgY29uc3QgbGNOYW1lID0gdHJhbnNmb3JtQ2FzZUZ1bmMobmFtZSk7XG4gICAgICBsZXQgdmFsdWUgPSBuYW1lID09PSAndmFsdWUnID8gYXR0clZhbHVlIDogc3RyaW5nVHJpbShhdHRyVmFsdWUpO1xuICAgICAgLyogRXhlY3V0ZSBhIGhvb2sgaWYgcHJlc2VudCAqL1xuICAgICAgaG9va0V2ZW50LmF0dHJOYW1lID0gbGNOYW1lO1xuICAgICAgaG9va0V2ZW50LmF0dHJWYWx1ZSA9IHZhbHVlO1xuICAgICAgaG9va0V2ZW50LmtlZXBBdHRyID0gdHJ1ZTtcbiAgICAgIGhvb2tFdmVudC5mb3JjZUtlZXBBdHRyID0gdW5kZWZpbmVkOyAvLyBBbGxvd3MgZGV2ZWxvcGVycyB0byBzZWUgdGhpcyBpcyBhIHByb3BlcnR5IHRoZXkgY2FuIHNldFxuICAgICAgX2V4ZWN1dGVIb29rcyhob29rcy51cG9uU2FuaXRpemVBdHRyaWJ1dGUsIGN1cnJlbnROb2RlLCBob29rRXZlbnQpO1xuICAgICAgdmFsdWUgPSBob29rRXZlbnQuYXR0clZhbHVlO1xuICAgICAgLyogRnVsbCBET00gQ2xvYmJlcmluZyBwcm90ZWN0aW9uIHZpYSBuYW1lc3BhY2UgaXNvbGF0aW9uLFxuICAgICAgICogUHJlZml4IGlkIGFuZCBuYW1lIGF0dHJpYnV0ZXMgd2l0aCBgdXNlci1jb250ZW50LWBcbiAgICAgICAqL1xuICAgICAgaWYgKFNBTklUSVpFX05BTUVEX1BST1BTICYmIChsY05hbWUgPT09ICdpZCcgfHwgbGNOYW1lID09PSAnbmFtZScpKSB7XG4gICAgICAgIC8vIFJlbW92ZSB0aGUgYXR0cmlidXRlIHdpdGggdGhpcyB2YWx1ZVxuICAgICAgICBfcmVtb3ZlQXR0cmlidXRlKG5hbWUsIGN1cnJlbnROb2RlKTtcbiAgICAgICAgLy8gUHJlZml4IHRoZSB2YWx1ZSBhbmQgbGF0ZXIgcmUtY3JlYXRlIHRoZSBhdHRyaWJ1dGUgd2l0aCB0aGUgc2FuaXRpemVkIHZhbHVlXG4gICAgICAgIHZhbHVlID0gU0FOSVRJWkVfTkFNRURfUFJPUFNfUFJFRklYICsgdmFsdWU7XG4gICAgICB9XG4gICAgICAvKiBXb3JrIGFyb3VuZCBhIHNlY3VyaXR5IGlzc3VlIHdpdGggY29tbWVudHMgaW5zaWRlIGF0dHJpYnV0ZXMgKi9cbiAgICAgIGlmIChTQUZFX0ZPUl9YTUwgJiYgcmVnRXhwVGVzdCgvKCgtLSE/fF0pPil8PFxcLyhzdHlsZXx0aXRsZSkvaSwgdmFsdWUpKSB7XG4gICAgICAgIF9yZW1vdmVBdHRyaWJ1dGUobmFtZSwgY3VycmVudE5vZGUpO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIC8qIERpZCB0aGUgaG9va3MgYXBwcm92ZSBvZiB0aGUgYXR0cmlidXRlPyAqL1xuICAgICAgaWYgKGhvb2tFdmVudC5mb3JjZUtlZXBBdHRyKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgLyogUmVtb3ZlIGF0dHJpYnV0ZSAqL1xuICAgICAgX3JlbW92ZUF0dHJpYnV0ZShuYW1lLCBjdXJyZW50Tm9kZSk7XG4gICAgICAvKiBEaWQgdGhlIGhvb2tzIGFwcHJvdmUgb2YgdGhlIGF0dHJpYnV0ZT8gKi9cbiAgICAgIGlmICghaG9va0V2ZW50LmtlZXBBdHRyKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgLyogV29yayBhcm91bmQgYSBzZWN1cml0eSBpc3N1ZSBpbiBqUXVlcnkgMy4wICovXG4gICAgICBpZiAoIUFMTE9XX1NFTEZfQ0xPU0VfSU5fQVRUUiAmJiByZWdFeHBUZXN0KC9cXC8+L2ksIHZhbHVlKSkge1xuICAgICAgICBfcmVtb3ZlQXR0cmlidXRlKG5hbWUsIGN1cnJlbnROb2RlKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICAvKiBTYW5pdGl6ZSBhdHRyaWJ1dGUgY29udGVudCB0byBiZSB0ZW1wbGF0ZS1zYWZlICovXG4gICAgICBpZiAoU0FGRV9GT1JfVEVNUExBVEVTKSB7XG4gICAgICAgIGFycmF5Rm9yRWFjaChbTVVTVEFDSEVfRVhQUiwgRVJCX0VYUFIsIFRNUExJVF9FWFBSXSwgZXhwciA9PiB7XG4gICAgICAgICAgdmFsdWUgPSBzdHJpbmdSZXBsYWNlKHZhbHVlLCBleHByLCAnICcpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIC8qIElzIGB2YWx1ZWAgdmFsaWQgZm9yIHRoaXMgYXR0cmlidXRlPyAqL1xuICAgICAgY29uc3QgbGNUYWcgPSB0cmFuc2Zvcm1DYXNlRnVuYyhjdXJyZW50Tm9kZS5ub2RlTmFtZSk7XG4gICAgICBpZiAoIV9pc1ZhbGlkQXR0cmlidXRlKGxjVGFnLCBsY05hbWUsIHZhbHVlKSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIC8qIEhhbmRsZSBhdHRyaWJ1dGVzIHRoYXQgcmVxdWlyZSBUcnVzdGVkIFR5cGVzICovXG4gICAgICBpZiAodHJ1c3RlZFR5cGVzUG9saWN5ICYmIHR5cGVvZiB0cnVzdGVkVHlwZXMgPT09ICdvYmplY3QnICYmIHR5cGVvZiB0cnVzdGVkVHlwZXMuZ2V0QXR0cmlidXRlVHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBpZiAobmFtZXNwYWNlVVJJKSA7IGVsc2Uge1xuICAgICAgICAgIHN3aXRjaCAodHJ1c3RlZFR5cGVzLmdldEF0dHJpYnV0ZVR5cGUobGNUYWcsIGxjTmFtZSkpIHtcbiAgICAgICAgICAgIGNhc2UgJ1RydXN0ZWRIVE1MJzpcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gdHJ1c3RlZFR5cGVzUG9saWN5LmNyZWF0ZUhUTUwodmFsdWUpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlICdUcnVzdGVkU2NyaXB0VVJMJzpcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gdHJ1c3RlZFR5cGVzUG9saWN5LmNyZWF0ZVNjcmlwdFVSTCh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8qIEhhbmRsZSBpbnZhbGlkIGRhdGEtKiBhdHRyaWJ1dGUgc2V0IGJ5IHRyeS1jYXRjaGluZyBpdCAqL1xuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKG5hbWVzcGFjZVVSSSkge1xuICAgICAgICAgIGN1cnJlbnROb2RlLnNldEF0dHJpYnV0ZU5TKG5hbWVzcGFjZVVSSSwgbmFtZSwgdmFsdWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8qIEZhbGxiYWNrIHRvIHNldEF0dHJpYnV0ZSgpIGZvciBicm93c2VyLXVucmVjb2duaXplZCBuYW1lc3BhY2VzIGUuZy4gXCJ4LXNjaGVtYVwiLiAqL1xuICAgICAgICAgIGN1cnJlbnROb2RlLnNldEF0dHJpYnV0ZShuYW1lLCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKF9pc0Nsb2JiZXJlZChjdXJyZW50Tm9kZSkpIHtcbiAgICAgICAgICBfZm9yY2VSZW1vdmUoY3VycmVudE5vZGUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGFycmF5UG9wKERPTVB1cmlmeS5yZW1vdmVkKTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoXykge31cbiAgICB9XG4gICAgLyogRXhlY3V0ZSBhIGhvb2sgaWYgcHJlc2VudCAqL1xuICAgIF9leGVjdXRlSG9va3MoaG9va3MuYWZ0ZXJTYW5pdGl6ZUF0dHJpYnV0ZXMsIGN1cnJlbnROb2RlLCBudWxsKTtcbiAgfTtcbiAgLyoqXG4gICAqIF9zYW5pdGl6ZVNoYWRvd0RPTVxuICAgKlxuICAgKiBAcGFyYW0gZnJhZ21lbnQgdG8gaXRlcmF0ZSBvdmVyIHJlY3Vyc2l2ZWx5XG4gICAqL1xuICBjb25zdCBfc2FuaXRpemVTaGFkb3dET00gPSBmdW5jdGlvbiBfc2FuaXRpemVTaGFkb3dET00oZnJhZ21lbnQpIHtcbiAgICBsZXQgc2hhZG93Tm9kZSA9IG51bGw7XG4gICAgY29uc3Qgc2hhZG93SXRlcmF0b3IgPSBfY3JlYXRlTm9kZUl0ZXJhdG9yKGZyYWdtZW50KTtcbiAgICAvKiBFeGVjdXRlIGEgaG9vayBpZiBwcmVzZW50ICovXG4gICAgX2V4ZWN1dGVIb29rcyhob29rcy5iZWZvcmVTYW5pdGl6ZVNoYWRvd0RPTSwgZnJhZ21lbnQsIG51bGwpO1xuICAgIHdoaWxlIChzaGFkb3dOb2RlID0gc2hhZG93SXRlcmF0b3IubmV4dE5vZGUoKSkge1xuICAgICAgLyogRXhlY3V0ZSBhIGhvb2sgaWYgcHJlc2VudCAqL1xuICAgICAgX2V4ZWN1dGVIb29rcyhob29rcy51cG9uU2FuaXRpemVTaGFkb3dOb2RlLCBzaGFkb3dOb2RlLCBudWxsKTtcbiAgICAgIC8qIFNhbml0aXplIHRhZ3MgYW5kIGVsZW1lbnRzICovXG4gICAgICBfc2FuaXRpemVFbGVtZW50cyhzaGFkb3dOb2RlKTtcbiAgICAgIC8qIENoZWNrIGF0dHJpYnV0ZXMgbmV4dCAqL1xuICAgICAgX3Nhbml0aXplQXR0cmlidXRlcyhzaGFkb3dOb2RlKTtcbiAgICAgIC8qIERlZXAgc2hhZG93IERPTSBkZXRlY3RlZCAqL1xuICAgICAgaWYgKHNoYWRvd05vZGUuY29udGVudCBpbnN0YW5jZW9mIERvY3VtZW50RnJhZ21lbnQpIHtcbiAgICAgICAgX3Nhbml0aXplU2hhZG93RE9NKHNoYWRvd05vZGUuY29udGVudCk7XG4gICAgICB9XG4gICAgfVxuICAgIC8qIEV4ZWN1dGUgYSBob29rIGlmIHByZXNlbnQgKi9cbiAgICBfZXhlY3V0ZUhvb2tzKGhvb2tzLmFmdGVyU2FuaXRpemVTaGFkb3dET00sIGZyYWdtZW50LCBudWxsKTtcbiAgfTtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGNvbXBsZXhpdHlcbiAgRE9NUHVyaWZ5LnNhbml0aXplID0gZnVuY3Rpb24gKGRpcnR5KSB7XG4gICAgbGV0IGNmZyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gICAgbGV0IGJvZHkgPSBudWxsO1xuICAgIGxldCBpbXBvcnRlZE5vZGUgPSBudWxsO1xuICAgIGxldCBjdXJyZW50Tm9kZSA9IG51bGw7XG4gICAgbGV0IHJldHVybk5vZGUgPSBudWxsO1xuICAgIC8qIE1ha2Ugc3VyZSB3ZSBoYXZlIGEgc3RyaW5nIHRvIHNhbml0aXplLlxuICAgICAgRE8gTk9UIHJldHVybiBlYXJseSwgYXMgdGhpcyB3aWxsIHJldHVybiB0aGUgd3JvbmcgdHlwZSBpZlxuICAgICAgdGhlIHVzZXIgaGFzIHJlcXVlc3RlZCBhIERPTSBvYmplY3QgcmF0aGVyIHRoYW4gYSBzdHJpbmcgKi9cbiAgICBJU19FTVBUWV9JTlBVVCA9ICFkaXJ0eTtcbiAgICBpZiAoSVNfRU1QVFlfSU5QVVQpIHtcbiAgICAgIGRpcnR5ID0gJzwhLS0+JztcbiAgICB9XG4gICAgLyogU3RyaW5naWZ5LCBpbiBjYXNlIGRpcnR5IGlzIGFuIG9iamVjdCAqL1xuICAgIGlmICh0eXBlb2YgZGlydHkgIT09ICdzdHJpbmcnICYmICFfaXNOb2RlKGRpcnR5KSkge1xuICAgICAgaWYgKHR5cGVvZiBkaXJ0eS50b1N0cmluZyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBkaXJ0eSA9IGRpcnR5LnRvU3RyaW5nKCk7XG4gICAgICAgIGlmICh0eXBlb2YgZGlydHkgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgdGhyb3cgdHlwZUVycm9yQ3JlYXRlKCdkaXJ0eSBpcyBub3QgYSBzdHJpbmcsIGFib3J0aW5nJyk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IHR5cGVFcnJvckNyZWF0ZSgndG9TdHJpbmcgaXMgbm90IGEgZnVuY3Rpb24nKTtcbiAgICAgIH1cbiAgICB9XG4gICAgLyogUmV0dXJuIGRpcnR5IEhUTUwgaWYgRE9NUHVyaWZ5IGNhbm5vdCBydW4gKi9cbiAgICBpZiAoIURPTVB1cmlmeS5pc1N1cHBvcnRlZCkge1xuICAgICAgcmV0dXJuIGRpcnR5O1xuICAgIH1cbiAgICAvKiBBc3NpZ24gY29uZmlnIHZhcnMgKi9cbiAgICBpZiAoIVNFVF9DT05GSUcpIHtcbiAgICAgIF9wYXJzZUNvbmZpZyhjZmcpO1xuICAgIH1cbiAgICAvKiBDbGVhbiB1cCByZW1vdmVkIGVsZW1lbnRzICovXG4gICAgRE9NUHVyaWZ5LnJlbW92ZWQgPSBbXTtcbiAgICAvKiBDaGVjayBpZiBkaXJ0eSBpcyBjb3JyZWN0bHkgdHlwZWQgZm9yIElOX1BMQUNFICovXG4gICAgaWYgKHR5cGVvZiBkaXJ0eSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIElOX1BMQUNFID0gZmFsc2U7XG4gICAgfVxuICAgIGlmIChJTl9QTEFDRSkge1xuICAgICAgLyogRG8gc29tZSBlYXJseSBwcmUtc2FuaXRpemF0aW9uIHRvIGF2b2lkIHVuc2FmZSByb290IG5vZGVzICovXG4gICAgICBpZiAoZGlydHkubm9kZU5hbWUpIHtcbiAgICAgICAgY29uc3QgdGFnTmFtZSA9IHRyYW5zZm9ybUNhc2VGdW5jKGRpcnR5Lm5vZGVOYW1lKTtcbiAgICAgICAgaWYgKCFBTExPV0VEX1RBR1NbdGFnTmFtZV0gfHwgRk9SQklEX1RBR1NbdGFnTmFtZV0pIHtcbiAgICAgICAgICB0aHJvdyB0eXBlRXJyb3JDcmVhdGUoJ3Jvb3Qgbm9kZSBpcyBmb3JiaWRkZW4gYW5kIGNhbm5vdCBiZSBzYW5pdGl6ZWQgaW4tcGxhY2UnKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoZGlydHkgaW5zdGFuY2VvZiBOb2RlKSB7XG4gICAgICAvKiBJZiBkaXJ0eSBpcyBhIERPTSBlbGVtZW50LCBhcHBlbmQgdG8gYW4gZW1wdHkgZG9jdW1lbnQgdG8gYXZvaWRcbiAgICAgICAgIGVsZW1lbnRzIGJlaW5nIHN0cmlwcGVkIGJ5IHRoZSBwYXJzZXIgKi9cbiAgICAgIGJvZHkgPSBfaW5pdERvY3VtZW50KCc8IS0tLS0+Jyk7XG4gICAgICBpbXBvcnRlZE5vZGUgPSBib2R5Lm93bmVyRG9jdW1lbnQuaW1wb3J0Tm9kZShkaXJ0eSwgdHJ1ZSk7XG4gICAgICBpZiAoaW1wb3J0ZWROb2RlLm5vZGVUeXBlID09PSBOT0RFX1RZUEUuZWxlbWVudCAmJiBpbXBvcnRlZE5vZGUubm9kZU5hbWUgPT09ICdCT0RZJykge1xuICAgICAgICAvKiBOb2RlIGlzIGFscmVhZHkgYSBib2R5LCB1c2UgYXMgaXMgKi9cbiAgICAgICAgYm9keSA9IGltcG9ydGVkTm9kZTtcbiAgICAgIH0gZWxzZSBpZiAoaW1wb3J0ZWROb2RlLm5vZGVOYW1lID09PSAnSFRNTCcpIHtcbiAgICAgICAgYm9keSA9IGltcG9ydGVkTm9kZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSB1bmljb3JuL3ByZWZlci1kb20tbm9kZS1hcHBlbmRcbiAgICAgICAgYm9keS5hcHBlbmRDaGlsZChpbXBvcnRlZE5vZGUpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvKiBFeGl0IGRpcmVjdGx5IGlmIHdlIGhhdmUgbm90aGluZyB0byBkbyAqL1xuICAgICAgaWYgKCFSRVRVUk5fRE9NICYmICFTQUZFX0ZPUl9URU1QTEFURVMgJiYgIVdIT0xFX0RPQ1VNRU5UICYmXG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgdW5pY29ybi9wcmVmZXItaW5jbHVkZXNcbiAgICAgIGRpcnR5LmluZGV4T2YoJzwnKSA9PT0gLTEpIHtcbiAgICAgICAgcmV0dXJuIHRydXN0ZWRUeXBlc1BvbGljeSAmJiBSRVRVUk5fVFJVU1RFRF9UWVBFID8gdHJ1c3RlZFR5cGVzUG9saWN5LmNyZWF0ZUhUTUwoZGlydHkpIDogZGlydHk7XG4gICAgICB9XG4gICAgICAvKiBJbml0aWFsaXplIHRoZSBkb2N1bWVudCB0byB3b3JrIG9uICovXG4gICAgICBib2R5ID0gX2luaXREb2N1bWVudChkaXJ0eSk7XG4gICAgICAvKiBDaGVjayB3ZSBoYXZlIGEgRE9NIG5vZGUgZnJvbSB0aGUgZGF0YSAqL1xuICAgICAgaWYgKCFib2R5KSB7XG4gICAgICAgIHJldHVybiBSRVRVUk5fRE9NID8gbnVsbCA6IFJFVFVSTl9UUlVTVEVEX1RZUEUgPyBlbXB0eUhUTUwgOiAnJztcbiAgICAgIH1cbiAgICB9XG4gICAgLyogUmVtb3ZlIGZpcnN0IGVsZW1lbnQgbm9kZSAob3VycykgaWYgRk9SQ0VfQk9EWSBpcyBzZXQgKi9cbiAgICBpZiAoYm9keSAmJiBGT1JDRV9CT0RZKSB7XG4gICAgICBfZm9yY2VSZW1vdmUoYm9keS5maXJzdENoaWxkKTtcbiAgICB9XG4gICAgLyogR2V0IG5vZGUgaXRlcmF0b3IgKi9cbiAgICBjb25zdCBub2RlSXRlcmF0b3IgPSBfY3JlYXRlTm9kZUl0ZXJhdG9yKElOX1BMQUNFID8gZGlydHkgOiBib2R5KTtcbiAgICAvKiBOb3cgc3RhcnQgaXRlcmF0aW5nIG92ZXIgdGhlIGNyZWF0ZWQgZG9jdW1lbnQgKi9cbiAgICB3aGlsZSAoY3VycmVudE5vZGUgPSBub2RlSXRlcmF0b3IubmV4dE5vZGUoKSkge1xuICAgICAgLyogU2FuaXRpemUgdGFncyBhbmQgZWxlbWVudHMgKi9cbiAgICAgIF9zYW5pdGl6ZUVsZW1lbnRzKGN1cnJlbnROb2RlKTtcbiAgICAgIC8qIENoZWNrIGF0dHJpYnV0ZXMgbmV4dCAqL1xuICAgICAgX3Nhbml0aXplQXR0cmlidXRlcyhjdXJyZW50Tm9kZSk7XG4gICAgICAvKiBTaGFkb3cgRE9NIGRldGVjdGVkLCBzYW5pdGl6ZSBpdCAqL1xuICAgICAgaWYgKGN1cnJlbnROb2RlLmNvbnRlbnQgaW5zdGFuY2VvZiBEb2N1bWVudEZyYWdtZW50KSB7XG4gICAgICAgIF9zYW5pdGl6ZVNoYWRvd0RPTShjdXJyZW50Tm9kZS5jb250ZW50KTtcbiAgICAgIH1cbiAgICB9XG4gICAgLyogSWYgd2Ugc2FuaXRpemVkIGBkaXJ0eWAgaW4tcGxhY2UsIHJldHVybiBpdC4gKi9cbiAgICBpZiAoSU5fUExBQ0UpIHtcbiAgICAgIHJldHVybiBkaXJ0eTtcbiAgICB9XG4gICAgLyogUmV0dXJuIHNhbml0aXplZCBzdHJpbmcgb3IgRE9NICovXG4gICAgaWYgKFJFVFVSTl9ET00pIHtcbiAgICAgIGlmIChSRVRVUk5fRE9NX0ZSQUdNRU5UKSB7XG4gICAgICAgIHJldHVybk5vZGUgPSBjcmVhdGVEb2N1bWVudEZyYWdtZW50LmNhbGwoYm9keS5vd25lckRvY3VtZW50KTtcbiAgICAgICAgd2hpbGUgKGJvZHkuZmlyc3RDaGlsZCkge1xuICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSB1bmljb3JuL3ByZWZlci1kb20tbm9kZS1hcHBlbmRcbiAgICAgICAgICByZXR1cm5Ob2RlLmFwcGVuZENoaWxkKGJvZHkuZmlyc3RDaGlsZCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybk5vZGUgPSBib2R5O1xuICAgICAgfVxuICAgICAgaWYgKEFMTE9XRURfQVRUUi5zaGFkb3dyb290IHx8IEFMTE9XRURfQVRUUi5zaGFkb3dyb290bW9kZSkge1xuICAgICAgICAvKlxuICAgICAgICAgIEFkb3B0Tm9kZSgpIGlzIG5vdCB1c2VkIGJlY2F1c2UgaW50ZXJuYWwgc3RhdGUgaXMgbm90IHJlc2V0XG4gICAgICAgICAgKGUuZy4gdGhlIHBhc3QgbmFtZXMgbWFwIG9mIGEgSFRNTEZvcm1FbGVtZW50KSwgdGhpcyBpcyBzYWZlXG4gICAgICAgICAgaW4gdGhlb3J5IGJ1dCB3ZSB3b3VsZCByYXRoZXIgbm90IHJpc2sgYW5vdGhlciBhdHRhY2sgdmVjdG9yLlxuICAgICAgICAgIFRoZSBzdGF0ZSB0aGF0IGlzIGNsb25lZCBieSBpbXBvcnROb2RlKCkgaXMgZXhwbGljaXRseSBkZWZpbmVkXG4gICAgICAgICAgYnkgdGhlIHNwZWNzLlxuICAgICAgICAqL1xuICAgICAgICByZXR1cm5Ob2RlID0gaW1wb3J0Tm9kZS5jYWxsKG9yaWdpbmFsRG9jdW1lbnQsIHJldHVybk5vZGUsIHRydWUpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJldHVybk5vZGU7XG4gICAgfVxuICAgIGxldCBzZXJpYWxpemVkSFRNTCA9IFdIT0xFX0RPQ1VNRU5UID8gYm9keS5vdXRlckhUTUwgOiBib2R5LmlubmVySFRNTDtcbiAgICAvKiBTZXJpYWxpemUgZG9jdHlwZSBpZiBhbGxvd2VkICovXG4gICAgaWYgKFdIT0xFX0RPQ1VNRU5UICYmIEFMTE9XRURfVEFHU1snIWRvY3R5cGUnXSAmJiBib2R5Lm93bmVyRG9jdW1lbnQgJiYgYm9keS5vd25lckRvY3VtZW50LmRvY3R5cGUgJiYgYm9keS5vd25lckRvY3VtZW50LmRvY3R5cGUubmFtZSAmJiByZWdFeHBUZXN0KERPQ1RZUEVfTkFNRSwgYm9keS5vd25lckRvY3VtZW50LmRvY3R5cGUubmFtZSkpIHtcbiAgICAgIHNlcmlhbGl6ZWRIVE1MID0gJzwhRE9DVFlQRSAnICsgYm9keS5vd25lckRvY3VtZW50LmRvY3R5cGUubmFtZSArICc+XFxuJyArIHNlcmlhbGl6ZWRIVE1MO1xuICAgIH1cbiAgICAvKiBTYW5pdGl6ZSBmaW5hbCBzdHJpbmcgdGVtcGxhdGUtc2FmZSAqL1xuICAgIGlmIChTQUZFX0ZPUl9URU1QTEFURVMpIHtcbiAgICAgIGFycmF5Rm9yRWFjaChbTVVTVEFDSEVfRVhQUiwgRVJCX0VYUFIsIFRNUExJVF9FWFBSXSwgZXhwciA9PiB7XG4gICAgICAgIHNlcmlhbGl6ZWRIVE1MID0gc3RyaW5nUmVwbGFjZShzZXJpYWxpemVkSFRNTCwgZXhwciwgJyAnKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1c3RlZFR5cGVzUG9saWN5ICYmIFJFVFVSTl9UUlVTVEVEX1RZUEUgPyB0cnVzdGVkVHlwZXNQb2xpY3kuY3JlYXRlSFRNTChzZXJpYWxpemVkSFRNTCkgOiBzZXJpYWxpemVkSFRNTDtcbiAgfTtcbiAgRE9NUHVyaWZ5LnNldENvbmZpZyA9IGZ1bmN0aW9uICgpIHtcbiAgICBsZXQgY2ZnID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcbiAgICBfcGFyc2VDb25maWcoY2ZnKTtcbiAgICBTRVRfQ09ORklHID0gdHJ1ZTtcbiAgfTtcbiAgRE9NUHVyaWZ5LmNsZWFyQ29uZmlnID0gZnVuY3Rpb24gKCkge1xuICAgIENPTkZJRyA9IG51bGw7XG4gICAgU0VUX0NPTkZJRyA9IGZhbHNlO1xuICB9O1xuICBET01QdXJpZnkuaXNWYWxpZEF0dHJpYnV0ZSA9IGZ1bmN0aW9uICh0YWcsIGF0dHIsIHZhbHVlKSB7XG4gICAgLyogSW5pdGlhbGl6ZSBzaGFyZWQgY29uZmlnIHZhcnMgaWYgbmVjZXNzYXJ5LiAqL1xuICAgIGlmICghQ09ORklHKSB7XG4gICAgICBfcGFyc2VDb25maWcoe30pO1xuICAgIH1cbiAgICBjb25zdCBsY1RhZyA9IHRyYW5zZm9ybUNhc2VGdW5jKHRhZyk7XG4gICAgY29uc3QgbGNOYW1lID0gdHJhbnNmb3JtQ2FzZUZ1bmMoYXR0cik7XG4gICAgcmV0dXJuIF9pc1ZhbGlkQXR0cmlidXRlKGxjVGFnLCBsY05hbWUsIHZhbHVlKTtcbiAgfTtcbiAgRE9NUHVyaWZ5LmFkZEhvb2sgPSBmdW5jdGlvbiAoZW50cnlQb2ludCwgaG9va0Z1bmN0aW9uKSB7XG4gICAgaWYgKHR5cGVvZiBob29rRnVuY3Rpb24gIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgYXJyYXlQdXNoKGhvb2tzW2VudHJ5UG9pbnRdLCBob29rRnVuY3Rpb24pO1xuICB9O1xuICBET01QdXJpZnkucmVtb3ZlSG9vayA9IGZ1bmN0aW9uIChlbnRyeVBvaW50LCBob29rRnVuY3Rpb24pIHtcbiAgICBpZiAoaG9va0Z1bmN0aW9uICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGNvbnN0IGluZGV4ID0gYXJyYXlMYXN0SW5kZXhPZihob29rc1tlbnRyeVBvaW50XSwgaG9va0Z1bmN0aW9uKTtcbiAgICAgIHJldHVybiBpbmRleCA9PT0gLTEgPyB1bmRlZmluZWQgOiBhcnJheVNwbGljZShob29rc1tlbnRyeVBvaW50XSwgaW5kZXgsIDEpWzBdO1xuICAgIH1cbiAgICByZXR1cm4gYXJyYXlQb3AoaG9va3NbZW50cnlQb2ludF0pO1xuICB9O1xuICBET01QdXJpZnkucmVtb3ZlSG9va3MgPSBmdW5jdGlvbiAoZW50cnlQb2ludCkge1xuICAgIGhvb2tzW2VudHJ5UG9pbnRdID0gW107XG4gIH07XG4gIERPTVB1cmlmeS5yZW1vdmVBbGxIb29rcyA9IGZ1bmN0aW9uICgpIHtcbiAgICBob29rcyA9IF9jcmVhdGVIb29rc01hcCgpO1xuICB9O1xuICByZXR1cm4gRE9NUHVyaWZ5O1xufVxudmFyIHB1cmlmeSA9IGNyZWF0ZURPTVB1cmlmeSgpO1xuXG5leHBvcnQgeyBwdXJpZnkgYXMgZGVmYXVsdCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cHVyaWZ5LmVzLm1qcy5tYXBcbiJdLCJuYW1lcyI6WyJlbnRyaWVzIiwic2V0UHJvdG90eXBlT2YiLCJpc0Zyb3plbiIsImdldFByb3RvdHlwZU9mIiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yIiwiT2JqZWN0IiwiZnJlZXplIiwic2VhbCIsImNyZWF0ZSIsImFwcGx5IiwiY29uc3RydWN0IiwiUmVmbGVjdCIsIngiLCJmdW4iLCJ0aGlzVmFsdWUiLCJhcmdzIiwiRnVuYyIsImFycmF5Rm9yRWFjaCIsInVuYXBwbHkiLCJBcnJheSIsInByb3RvdHlwZSIsImZvckVhY2giLCJhcnJheUxhc3RJbmRleE9mIiwibGFzdEluZGV4T2YiLCJhcnJheVBvcCIsInBvcCIsImFycmF5UHVzaCIsInB1c2giLCJhcnJheVNwbGljZSIsInNwbGljZSIsInN0cmluZ1RvTG93ZXJDYXNlIiwiU3RyaW5nIiwidG9Mb3dlckNhc2UiLCJzdHJpbmdUb1N0cmluZyIsInRvU3RyaW5nIiwic3RyaW5nTWF0Y2giLCJtYXRjaCIsInN0cmluZ1JlcGxhY2UiLCJyZXBsYWNlIiwic3RyaW5nSW5kZXhPZiIsImluZGV4T2YiLCJzdHJpbmdUcmltIiwidHJpbSIsIm9iamVjdEhhc093blByb3BlcnR5IiwiaGFzT3duUHJvcGVydHkiLCJyZWdFeHBUZXN0IiwiUmVnRXhwIiwidGVzdCIsInR5cGVFcnJvckNyZWF0ZSIsInVuY29uc3RydWN0IiwiVHlwZUVycm9yIiwiZnVuYyIsInRoaXNBcmciLCJfbGVuIiwiYXJndW1lbnRzIiwibGVuZ3RoIiwiX2tleSIsIl9sZW4yIiwiX2tleTIiLCJhZGRUb1NldCIsInNldCIsImFycmF5IiwidHJhbnNmb3JtQ2FzZUZ1bmMiLCJ1bmRlZmluZWQiLCJsIiwiZWxlbWVudCIsImxjRWxlbWVudCIsImNsZWFuQXJyYXkiLCJpbmRleCIsImlzUHJvcGVydHlFeGlzdCIsImNsb25lIiwib2JqZWN0IiwibmV3T2JqZWN0IiwicHJvcGVydHkiLCJ2YWx1ZSIsImlzQXJyYXkiLCJjb25zdHJ1Y3RvciIsImxvb2t1cEdldHRlciIsInByb3AiLCJkZXNjIiwiZ2V0IiwiZmFsbGJhY2tWYWx1ZSIsImh0bWwkMSIsInN2ZyQxIiwic3ZnRmlsdGVycyIsInN2Z0Rpc2FsbG93ZWQiLCJtYXRoTWwkMSIsIm1hdGhNbERpc2FsbG93ZWQiLCJ0ZXh0IiwiaHRtbCIsInN2ZyIsIm1hdGhNbCIsInhtbCIsIk1VU1RBQ0hFX0VYUFIiLCJFUkJfRVhQUiIsIlRNUExJVF9FWFBSIiwiREFUQV9BVFRSIiwiQVJJQV9BVFRSIiwiSVNfQUxMT1dFRF9VUkkiLCJJU19TQ1JJUFRfT1JfREFUQSIsIkFUVFJfV0hJVEVTUEFDRSIsIkRPQ1RZUEVfTkFNRSIsIkNVU1RPTV9FTEVNRU5UIiwiRVhQUkVTU0lPTlMiLCJfX3Byb3RvX18iLCJOT0RFX1RZUEUiLCJhdHRyaWJ1dGUiLCJjZGF0YVNlY3Rpb24iLCJlbnRpdHlSZWZlcmVuY2UiLCJlbnRpdHlOb2RlIiwicHJvZ3Jlc3NpbmdJbnN0cnVjdGlvbiIsImNvbW1lbnQiLCJkb2N1bWVudCIsImRvY3VtZW50VHlwZSIsImRvY3VtZW50RnJhZ21lbnQiLCJub3RhdGlvbiIsImdldEdsb2JhbCIsIndpbmRvdyIsIl9jcmVhdGVUcnVzdGVkVHlwZXNQb2xpY3kiLCJ0cnVzdGVkVHlwZXMiLCJwdXJpZnlIb3N0RWxlbWVudCIsImNyZWF0ZVBvbGljeSIsInN1ZmZpeCIsIkFUVFJfTkFNRSIsImhhc0F0dHJpYnV0ZSIsImdldEF0dHJpYnV0ZSIsInBvbGljeU5hbWUiLCJjcmVhdGVIVE1MIiwiY3JlYXRlU2NyaXB0VVJMIiwic2NyaXB0VXJsIiwiXyIsImNvbnNvbGUiLCJ3YXJuIiwiX2NyZWF0ZUhvb2tzTWFwIiwiYWZ0ZXJTYW5pdGl6ZUF0dHJpYnV0ZXMiLCJhZnRlclNhbml0aXplRWxlbWVudHMiLCJhZnRlclNhbml0aXplU2hhZG93RE9NIiwiYmVmb3JlU2FuaXRpemVBdHRyaWJ1dGVzIiwiYmVmb3JlU2FuaXRpemVFbGVtZW50cyIsImJlZm9yZVNhbml0aXplU2hhZG93RE9NIiwidXBvblNhbml0aXplQXR0cmlidXRlIiwidXBvblNhbml0aXplRWxlbWVudCIsInVwb25TYW5pdGl6ZVNoYWRvd05vZGUiLCJjcmVhdGVET01QdXJpZnkiLCJET01QdXJpZnkiLCJyb290IiwidmVyc2lvbiIsInJlbW92ZWQiLCJub2RlVHlwZSIsIkVsZW1lbnQiLCJpc1N1cHBvcnRlZCIsIm9yaWdpbmFsRG9jdW1lbnQiLCJjdXJyZW50U2NyaXB0IiwiRG9jdW1lbnRGcmFnbWVudCIsIkhUTUxUZW1wbGF0ZUVsZW1lbnQiLCJOb2RlIiwiTm9kZUZpbHRlciIsIk5hbWVkTm9kZU1hcCIsIk1vek5hbWVkQXR0ck1hcCIsIkhUTUxGb3JtRWxlbWVudCIsIkRPTVBhcnNlciIsIkVsZW1lbnRQcm90b3R5cGUiLCJjbG9uZU5vZGUiLCJyZW1vdmUiLCJnZXROZXh0U2libGluZyIsImdldENoaWxkTm9kZXMiLCJnZXRQYXJlbnROb2RlIiwidGVtcGxhdGUiLCJjcmVhdGVFbGVtZW50IiwiY29udGVudCIsIm93bmVyRG9jdW1lbnQiLCJ0cnVzdGVkVHlwZXNQb2xpY3kiLCJlbXB0eUhUTUwiLCJpbXBsZW1lbnRhdGlvbiIsImNyZWF0ZU5vZGVJdGVyYXRvciIsImNyZWF0ZURvY3VtZW50RnJhZ21lbnQiLCJnZXRFbGVtZW50c0J5VGFnTmFtZSIsImltcG9ydE5vZGUiLCJob29rcyIsImNyZWF0ZUhUTUxEb2N1bWVudCIsIklTX0FMTE9XRURfVVJJJDEiLCJBTExPV0VEX1RBR1MiLCJERUZBVUxUX0FMTE9XRURfVEFHUyIsIkFMTE9XRURfQVRUUiIsIkRFRkFVTFRfQUxMT1dFRF9BVFRSIiwiQ1VTVE9NX0VMRU1FTlRfSEFORExJTkciLCJ0YWdOYW1lQ2hlY2siLCJ3cml0YWJsZSIsImNvbmZpZ3VyYWJsZSIsImVudW1lcmFibGUiLCJhdHRyaWJ1dGVOYW1lQ2hlY2siLCJhbGxvd0N1c3RvbWl6ZWRCdWlsdEluRWxlbWVudHMiLCJGT1JCSURfVEFHUyIsIkZPUkJJRF9BVFRSIiwiQUxMT1dfQVJJQV9BVFRSIiwiQUxMT1dfREFUQV9BVFRSIiwiQUxMT1dfVU5LTk9XTl9QUk9UT0NPTFMiLCJBTExPV19TRUxGX0NMT1NFX0lOX0FUVFIiLCJTQUZFX0ZPUl9URU1QTEFURVMiLCJTQUZFX0ZPUl9YTUwiLCJXSE9MRV9ET0NVTUVOVCIsIlNFVF9DT05GSUciLCJGT1JDRV9CT0RZIiwiUkVUVVJOX0RPTSIsIlJFVFVSTl9ET01fRlJBR01FTlQiLCJSRVRVUk5fVFJVU1RFRF9UWVBFIiwiU0FOSVRJWkVfRE9NIiwiU0FOSVRJWkVfTkFNRURfUFJPUFMiLCJTQU5JVElaRV9OQU1FRF9QUk9QU19QUkVGSVgiLCJLRUVQX0NPTlRFTlQiLCJJTl9QTEFDRSIsIlVTRV9QUk9GSUxFUyIsIkZPUkJJRF9DT05URU5UUyIsIkRFRkFVTFRfRk9SQklEX0NPTlRFTlRTIiwiREFUQV9VUklfVEFHUyIsIkRFRkFVTFRfREFUQV9VUklfVEFHUyIsIlVSSV9TQUZFX0FUVFJJQlVURVMiLCJERUZBVUxUX1VSSV9TQUZFX0FUVFJJQlVURVMiLCJNQVRITUxfTkFNRVNQQUNFIiwiU1ZHX05BTUVTUEFDRSIsIkhUTUxfTkFNRVNQQUNFIiwiTkFNRVNQQUNFIiwiSVNfRU1QVFlfSU5QVVQiLCJBTExPV0VEX05BTUVTUEFDRVMiLCJERUZBVUxUX0FMTE9XRURfTkFNRVNQQUNFUyIsIk1BVEhNTF9URVhUX0lOVEVHUkFUSU9OX1BPSU5UUyIsIkhUTUxfSU5URUdSQVRJT05fUE9JTlRTIiwiQ09NTU9OX1NWR19BTkRfSFRNTF9FTEVNRU5UUyIsIlBBUlNFUl9NRURJQV9UWVBFIiwiU1VQUE9SVEVEX1BBUlNFUl9NRURJQV9UWVBFUyIsIkRFRkFVTFRfUEFSU0VSX01FRElBX1RZUEUiLCJDT05GSUciLCJmb3JtRWxlbWVudCIsImlzUmVnZXhPckZ1bmN0aW9uIiwidGVzdFZhbHVlIiwiRnVuY3Rpb24iLCJfcGFyc2VDb25maWciLCJjZmciLCJBRERfVVJJX1NBRkVfQVRUUiIsIkFERF9EQVRBX1VSSV9UQUdTIiwiQUxMT1dFRF9VUklfUkVHRVhQIiwiQUREX1RBR1MiLCJBRERfQVRUUiIsInRhYmxlIiwidGJvZHkiLCJUUlVTVEVEX1RZUEVTX1BPTElDWSIsIkFMTF9TVkdfVEFHUyIsIkFMTF9NQVRITUxfVEFHUyIsIl9jaGVja1ZhbGlkTmFtZXNwYWNlIiwicGFyZW50IiwidGFnTmFtZSIsIm5hbWVzcGFjZVVSSSIsInBhcmVudFRhZ05hbWUiLCJCb29sZWFuIiwiX2ZvcmNlUmVtb3ZlIiwibm9kZSIsInJlbW92ZUNoaWxkIiwiX3JlbW92ZUF0dHJpYnV0ZSIsIm5hbWUiLCJnZXRBdHRyaWJ1dGVOb2RlIiwiZnJvbSIsInJlbW92ZUF0dHJpYnV0ZSIsInNldEF0dHJpYnV0ZSIsIl9pbml0RG9jdW1lbnQiLCJkaXJ0eSIsImRvYyIsImxlYWRpbmdXaGl0ZXNwYWNlIiwibWF0Y2hlcyIsImRpcnR5UGF5bG9hZCIsInBhcnNlRnJvbVN0cmluZyIsImRvY3VtZW50RWxlbWVudCIsImNyZWF0ZURvY3VtZW50IiwiaW5uZXJIVE1MIiwiYm9keSIsImluc2VydEJlZm9yZSIsImNyZWF0ZVRleHROb2RlIiwiY2hpbGROb2RlcyIsImNhbGwiLCJfY3JlYXRlTm9kZUl0ZXJhdG9yIiwiU0hPV19FTEVNRU5UIiwiU0hPV19DT01NRU5UIiwiU0hPV19URVhUIiwiU0hPV19QUk9DRVNTSU5HX0lOU1RSVUNUSU9OIiwiU0hPV19DREFUQV9TRUNUSU9OIiwiX2lzQ2xvYmJlcmVkIiwibm9kZU5hbWUiLCJ0ZXh0Q29udGVudCIsImF0dHJpYnV0ZXMiLCJoYXNDaGlsZE5vZGVzIiwiX2lzTm9kZSIsIl9leGVjdXRlSG9va3MiLCJjdXJyZW50Tm9kZSIsImRhdGEiLCJob29rIiwiX3Nhbml0aXplRWxlbWVudHMiLCJhbGxvd2VkVGFncyIsImZpcnN0RWxlbWVudENoaWxkIiwiX2lzQmFzaWNDdXN0b21FbGVtZW50IiwicGFyZW50Tm9kZSIsImNoaWxkQ291bnQiLCJpIiwiY2hpbGRDbG9uZSIsIl9fcmVtb3ZhbENvdW50IiwiZXhwciIsIl9pc1ZhbGlkQXR0cmlidXRlIiwibGNUYWciLCJsY05hbWUiLCJfc2FuaXRpemVBdHRyaWJ1dGVzIiwiaG9va0V2ZW50IiwiYXR0ck5hbWUiLCJhdHRyVmFsdWUiLCJrZWVwQXR0ciIsImFsbG93ZWRBdHRyaWJ1dGVzIiwiZm9yY2VLZWVwQXR0ciIsImF0dHIiLCJnZXRBdHRyaWJ1dGVUeXBlIiwic2V0QXR0cmlidXRlTlMiLCJfc2FuaXRpemVTaGFkb3dET00iLCJmcmFnbWVudCIsInNoYWRvd05vZGUiLCJzaGFkb3dJdGVyYXRvciIsIm5leHROb2RlIiwic2FuaXRpemUiLCJpbXBvcnRlZE5vZGUiLCJyZXR1cm5Ob2RlIiwiYXBwZW5kQ2hpbGQiLCJmaXJzdENoaWxkIiwibm9kZUl0ZXJhdG9yIiwic2hhZG93cm9vdCIsInNoYWRvd3Jvb3Rtb2RlIiwic2VyaWFsaXplZEhUTUwiLCJvdXRlckhUTUwiLCJkb2N0eXBlIiwic2V0Q29uZmlnIiwiY2xlYXJDb25maWciLCJpc1ZhbGlkQXR0cmlidXRlIiwidGFnIiwiYWRkSG9vayIsImVudHJ5UG9pbnQiLCJob29rRnVuY3Rpb24iLCJyZW1vdmVIb29rIiwicmVtb3ZlSG9va3MiLCJyZW1vdmVBbGxIb29rcyIsInB1cmlmeSIsImRlZmF1bHQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/dompurify/dist/purify.es.mjs\n");

/***/ })

};
;